# Основные приципы тестирования в Rails 4
Конспект по книги Rails 4 Test Prescriptions by Noel Rappin

## Содержание

1. Введение
2. Основы разработки через тестирование
3. Тестирование в Rails
4. Как сделать тесты лучше
5. Тестирование моделей
6. Добавление данных в тесты
7. Использование подделок: фиктивные объекты и заглушки
8. [**Тестирование контроллеров и представлений**](#user-content-chapter-8)
  * [Тестирование контроллеров](#user-content-chapter-8.1)
  * [Имитирование запросов в тестах контроллеров](#user-content-chapter-8.2)
  * [Оценка результатов действия контроллера](#user-content-chapter-8.3)
  * [Тестирование маршрутов](#user-content-chapter-8.4)
  * [Тестирование вспомагательных методов (хелперов)](#user-content-chapter-8.5)
  * [Тестирование представлений](#user-content-chapter-8.6)
  * [Презентеры (Presenters)](#user-content-chapter-8.7)
  * [Тестирование рассыльщиков (Mailers)](#user-content-chapter-8.8)
  * [Управление тестами контроллеров и представлений](#user-content-chapter-8.9)
9. Minitest
10. [**Интеграционное тестирование с Capybara и Cucumber**](#user-content-chapter-10)
  * [Что тестировать в интеграционном тесте](#user-content-chapter-10.1)
  * [Настройка Capybara](#user-content-chapter-10.2)
  * [Тестирование "от общего к частному" (Outside-in)](#user-content-chapter-10.3)
  * [Использование Capybara](#user-content-chapter-10.4)
  * [Заставляя пройти тест Capybara](#user-content-chapter-10.5)
  * [Ретроспектива](#user-content-chapter-10.6)
  * [Пробуем Cucumber](#user-content-chapter-10.7)
  * [Настройка Cucumber](#user-content-chapter-10.8)
  * [Написание функций Cucumber](#user-content-chapter-10.9)
  * [Написание шагов Cucumber](#user-content-chapter-10.10)
  * [Более продвинутый Cucumber](#user-content-chapter-10.11)
  * [Стоит ли Cucumber того?](#user-content-chapter-10.12)
  * [Заглядывая вперед](#user-content-chapter-10.13)

<div id='user-content-chapter-8'/></div>
## 8. Тестирование контроллеров и представлений

<div id='user-content-chapter-8.1'/></div>
### Тестирование контроллеров

```ruby
# spec/controllers/projects_controller_spec.rb
require 'rails_helper'

RSpec.describe ProjectsController, type: controller do
  describe "POST create" do
    post :create, project: {name: "Runaway", tasks: "Start something:2"}
    expect(response).to redirect_to(projects_path)
    expect(assigns(:action).project.name).to eq("Runaway")
  end
end
```

Это простой пример теста контроллера. Теста контроллера обычно состоит из 3-х частей:
 1. Тест контроллера может создать данные для тестирования (в тесте сверху мы не нуждаемся в данных, но мы увидим их в следующих примерах тестов);
 2. Выполнения действия: *post :create, project: {name: "Runaway", ...}*;
 3. Предположения отностительно поведения контроллера.

#### Что тестировать в контроллерах

> Принцип 20. Тест контроллера должен тестировать только поведение контроллера. **Тест контроллера не должен падать из-за проблем модели.**

Тест контроллера должен достигнуть одну или более из следующих целей:
 - Удостовериться, что обычный пользовательский запрос запускает вызов ожидаемой модели и отправляет нужные данные на представление;
 - Удостовериться, что неправильный запрос пользователя обрабатывается правильно (что значит "правильно", зависит от приложения);
 - Проверить сервисы, такие как требования логина или запрет просмотра страниц для заблокированных пользователей и т.д.

<div id='user-content-chapter-8.2'/></div>
### Имитирование запросов в тестах контроллеров

Полный запрос имеет пять аргументов (хотя используются обычно только три):

```ruby
get :show, {id: @task.id}, {user_id: "3", current_project: @project.id.to_s}, {notice: "flash test"}
```

Имя метода *get (delete, head, patch, post or put)* это HTTP-запрос, который имитируется. Проверка маршрутизации таким образом не производится, ее нужно тестировать отдельно.

Первый аргумент - в нашем случае *show* - это действие контроллера, которое вызывается. Второй аргумент - *{id: @task.id}* - это хэш, который становится параметрами в действии контроллера (*params[:id]*). *user: {name: "Noel", email: "noel@noelrappin.com"}* будет соответствовать *params[:user][:name] == "Noel"* в контроллере. 

Все параметры переданные в хэш будут автоматически конвертироваться в строку, по этому можно писать так: *id: 3*.

Если один из аргументов загружаемый файл, можно имитировать зазгрузку хелпером *fixture_file_uploader(filename, mimetype)*:

```ruby
post :create, logo: fixture_file_upload('test/data/logo.png', 'image/png')
```

При использовании сторонних сервисов, таких как Paperclip или CarrierWave, хелперы наверняка будут отличаться. 

Четвертый и пятый аргументы опциональны и используются редко. Четвертый аргумент устанавливает пары ключ/значения для объекта сессии. Пятый представляет Rails флэш-объект.

В тесте контроллера можно получить доступ к объекту запроса через переменную *@request*, а к объекту контроллера через *@controller*. Так же есть объект *@response*. Например, можно получить HTTP-headers через *@request.headers*.

Есть еще один метод действия контроллера: *xml_http_request* (псевдоним *xhr*). Он имитирует классический ajax-запрос и слегка отличается. 

```ruby
it "makes an ajax call" do
  xhr :post, :create, :task => {:id => "3"}
end
```

<div id='user-content-chapter-8.3'/></div>
### Оценка результатов действия контроллера

У теста контроллера есть три вещи, которые можно проверять после действия контроллера:
  1. Возвращается ли ожидаемый НТТР-статус? RSpec предоставляет для этого *response.status* объект и *have_http_status* сличитель (matcher);
  2. Передается ли управление определенному шаблону или выполняется ли перенаправление на действие контроллера? Для проверки есть *render_template* и *redirect_to* сличители.
  3. Устанавливаются ли ожидаемый значения? Для проверки есть специальный хэш-объекты *assigns, cookies, flash and session*.

Зачастую эти проверки комбинируются в одном тесте:
```ruby
it "is a successful index request with no filters" do
  get :index
  expect(response).to have_http_status(:success)
  expect(response).to render_template(:index)
end
```

#### Проверка типа ответа контроллера

| Symbol | HTTP Code Equivalent | Symbol  | HTTP Code Equivalent |
|--------|----------------------|---------|----------------------|
|:success|200-299               |:redirect|300-399               |
|:missing|404                   |:error   |500-599               |

#### Проверяем, какой шаблон рендерится

Сличитель *render_template* используется для определения, передается ли управление от контроллера к определенному шаблону представления. Аргументом является действие контроллера. 

Когда ожидается перенаправления, используется *redirect_to*. Аргументом является все, что Rails может конвертировать в url. Код *redirect_to* уже включает *have_http_status(:redirect)*, по этому дублировать проверку не нужно.

Если аргументом для *redirect_to* является название URL, то проверка пройдет **только** если перенаправляемый URL в точности совпадет с аргументом. Для тестирования Rails предполагает, что хост локального приложения *http://www.example.com*. Если это слишком точно, то можно передавать хэш аргументом для *redirect_to*, в котором указывать *:controller*, *:action* и т.д. 

Тесты Rails контроллеров не повторяют и **не следуют** перенаправлениям. Все проверки данных применимы только к методам до перенаправления. Если нужно следовать перенаправлению, то потребуется сделать интеграционный тест.

#### Проверка данных контроллера

Rails позволяет проверять данные сгенерированные действием контроллера, который тестируется, с . помощью четырех способов: *assigns*, *cookies*, *session* и *flash*. *assigns*, который предоставляет доступ к переменной экземпляра, объявленной в контроллере, используется чаще всего. Типичный пример может выглядеть подобный образом:

```ruby
it 'shows a task' do
  task = Task.create!
  get :show, id: task.id
  expect(response).to have_http_status(:success)
  expect(assigns(:task).id).to eq(task.id)
  expect(session[:previous_page]).to eq("task/show")
end
```

<div id='user-content-chapter-8.4'/></div>
### Тестирование маршрутов

Не смотря на то, что маршрутизация в Rails проста, иногда возникает путаница относительно того, что делает приложение при конвертации от URL к Rails действию. 

RSpec-Rails распологает тесты маршрутизации в директории *spec/routing*. Основной сличитель, используемый для тестирования маршрутов, *route_to*. 

```ruby
# spec/routing/project_routing_spec.rb
require 'rails_helper'

RSpec.describe "project routing" do
  it "routes projects" do
    expect(get: "/projects").to route_to(
      controller: "projects", action: "index")
    expect(post: "/projects").to route_to(
      controller: "projects", action: "create")
    expect(get: "/projects/new").to route_to(
      controller: "projects", action: "new")
    expect(get: "/projects/1").to route_to(
      controller: "projects", action: "show", id: "1")
    expect(get: "/projects/1/edit").to route_to(
      controller: "projects", action: "edit", id: "1")
    expect(patch: "/projects/1").to route_to(
      controller: "projects", action: "update", id: "1")
    expect(delete: "/projects/1").to route_to(
      controller: "projects", action: "destroy", id: "1")
  end
end
```

RSpec так же предоставляет метод *be_routable*, который служит для тестирования маршрутов, которые не показываются.

```ruby
expect(get: "/projects/search/fred").not_to be_routable
```

<div id='user-content-chapter-8.5'/></div>
### Тестирование вспомагательных методов (хелперов)

Вспомагательные модули разработаны для хранения многоразово используемых частей логики представления. Из-за того, что немного сложнее настроить их тестирование, вспомагательные методы часто не тестируются, даже если они содержат значительное количество логики приложения.

Предположим, что мы хотим изменить вид нашего проекта, чтобы отстающие от графика проекты отображались иначе. Мы может сделать это через вспомагательный метод. Я обычно добавляю CSS класс к выводу для обоих проектов: как обычных, так и отстающих. 

Вот тест для этого хелпера:

```ruby
# spec/helpers/projects_helper_spec.rb
require 'rails_helper'

RSpec.describe ProjectsHelper, :type => :helper do
  let(:project) { Project.new(name: "Project Runaway") }

  it "augments with status info" do
    allow(project).to receive(:on_schedule?).and_return(true)
    actual = helper.name_with_status(project)
    expect(actual).to have_selector("span.on_schedule", text: "Project Runaway")
  end
end
```

Этот тест создает проект используя стандартный ActiveRecord *new* метод. Вместо определения тучи задач, которые будут означать, что новый проект идет по графику, мы просто создаем метод-заглушку *on_schedule?*. 

Мы испольуем сличитель *have_selector* для сравнения ожидаемого HTML со сгенерированным. 

Тест будет провален, т.к. мы не определили метод. Давайте определим:

```ruby
# app/helpers/projects_helper.rb
module ProjectsHelper
  
  def name_with_status(project)
    content_tag(:span, project.name, class: 'on_schedule')
  end
end
```

Тест пройдет проверку; теперь добавим второй тест для оставшегося случая:

```ruby
# spec/helpers/projects_helper_spec.rb
it "augments project name with status info when behind schedule" do
  allow(project).to receive(:on_schedule?).and_return(false)
  actual = helper.name_with_status(project)
  expect(actual).to have_selector("span.behind_schedule", text: "Project Runaway")
end
```

И тест пройдет проверку при следующих изменения хелпера:

```ruby
# app/helpers/projects_helper.rb
module ProjectsHelper
  
  def name_with_status(project)
    dom_class = project.on_schedule? ? 'on_schedule' : 'behind_schedule'
    content_tag(:span, project.name, class: dom_class)
  end
end
```

О чем еще нужно беспокоится при тестировании представления, так это использование внутренних методов представлений Rails, таких как *url_for*. Хотя основные вспомагательные методы автоматически загружаются в тестовую среду ActionView, один или пара методов имеют важные зависимости на объекте контроллера и следовательно тесты падают. Выходом является определение метода в тесте через заглушку.

Иногда вспомагательные методы принимают блок, который должен быть ERB текстом. Например:

```ruby
def if_logged_in
  yield if logged_in?
end
```
Данный метод может быть вызван так:
```erb
<% if_logged_in %>
  <%= link_to "logout", logout_path %>
<% end %>
```

Для тестирования хелпера *if_logged_in* мы может воспользоваться тем фактом, что оператор *yield* это последнее выражение в методе и по этому является возвращаемым значением, а так же фактом, что Ruby позволит нам передать любую строку блоку.

```ruby
it "does not display if not logged_in" do
  expect(logged_in?).to be_falsy
  expect(if_logged_in {"logged in"}).to be_nil
end

it "displays if logged_in" do
  login_as users(:quentin)
  expect(logged_in?).to be_truthy
  expect(if_logged_in {"logged in"}).to eq("logged in")
end
```

Тут нужно быть аккуратным, т.к. эти тесты проверяют только возвращаемые методами значения, а не то, что отправляется на выход. Выходной поток - это часть стороннего эффекта процесса, но он хранится в переменной *output_buffer*, к которой можно получить доступ во время тестирования. Таким образом, данные тесты можно переписать:

```ruby
it "does not display if not logged_in" do
  expect(logged_in?).to be_falsy
  if_logged_in {"logged in"}
  expect(output_buffer).to be_nil
end

it "displays if logged_in" do
  login_as users(:quentin)
  expect(logged_in?).to be_truthy
  if_logged_in {"logged in"}
  expect(output_buffer).to be_nil
end
```

<div id='user-content-chapter-8.6'/></div>
### Тестирование представлений

Мы тестировали хелпер на статус проекта, но когда мы заходим в браузер DOM-элементы нового статуса не отображаются. Это потому, что мы не использовали хелпер на шаблоне представления. 

С точки зрения TDD у нас есть несколько вариантов:
 - Не писать тесты и просто вставить хелпер в шаблон представления. Технически мы не добавляем логику, по этому не добавление тестов может быть оправданным в случае, если тест: а) дорогой, б) незначительный и в) легко определяемый визуально.
 - Написать интеграционные тесты используя Capybara.
 - Написать тести представлений. У них преимущество в скорости перед интеграционными тестами и можем комбинировать их с уже написанными тестами контроллера.

План теста представления
 - Дано: Нам нужно всего два проекта: один, который вкладывается в график, второй - нет. Это позволит проверить оба варианта хелпера. Проект, который мы создаем, должен быть видим для метода контроллера, то есть мы должны либо добавить данные в БД, либо сделать подделку. (Так же можно использовать испытательные стенды (fixtures), но я не хочу их создавать, т.к. не хочу, чтоб данные проекты были глобальные.) Давайте начнем с БД, на данный момент это самое простое решение.
 - Условия: Нам просто нужно вызвать действие *index* контроллера.
 - Далее: У проекта, который вкладывается в график, DOM класс *on_schedule* и у опаздывающего проекта класс *behind_schedule*.

```ruby
# spec/views/projects/index.html.erb_spec.rb
require 'rails_helper'

describe "projects/index" do
  let(:completed_task) {Task.create!(completed_at: 1.day.ago, size: 1)}
  let(:on_schedule) {Project.create!(due_dateL 1.year.from_now,
    name: "On Schedule", tasks: [completed_task])}
  let(:incomplete_task) {Task.create!(size: 1)}
  let(:behind_schedule) {Project.create!(due_dateL 1.day.from_now,
    name: "Behind Schedule", tasks: [incomplete_task])}

  it "renders the index page with correct DOM elements" do
    @projects = [on_schedule, behind_schedule]
    render
    expect(rendered).to have_selector(
      "#project_#{on_schedule.id} .on_schedule")
    expect(rendered).to have_selector(
      "#project_#{behind_schedule.id} .behind_schedule")
  end
end
```

Сличитель *have_selector* не является частью RSpec, он относится к Capybara. 

Что делает этот тест?

Сначала мы создаем данные. Мы используем *let* для создания успевающего проекта и задания. Есть возможность сделать тест быстрее создавая проект и делая метод-заглушку *on_schedule?* или используя FactoryGirl.build_stubbed для создания реальных объектов без необходимости сохранять их в БД.

Секция "Условия" начинается на строке *render*, которая говорит RSpec рендерить представление, описанное во внешнем блоке *describe*. В нашем случае *projects/index*. Так же можно явно указать аргумент: *render template: "projects/index"*. Если представление парциальный шаблон, нужно указать это: *render partial: "projects/data_row"*. Необязательный аргумент *locals* вида ключ/значение указывает локальные переменные для парциала. Сокращенно можно так: *render "projects/data_row", project: @project*.

Все Rails хелперы загружены. Если захочется подделать одно из их значений, доступ к хелперам можно получить через *view* объект, например, *view.stub(:current_user).and_return(User.new)*. Так же можно использовать *stub_template* для подделки парциала, который не хочется рендерить; *stub_template* принимает пару ключ/значение, где ключ это точное имя парциала, а значение - строка, которая будет возвращена на месте отрендеренного парциала. 

В секции "Потом" рендерящийся текст доступен через метод *rendered*. Относительно ожиданий по его значению можно использовать любой RSpec сличитель. В этом тесте мы используем *have_selector*, но можем использовать *match* для простого сравнения с регулярным выражением.

Сличитель *have_selector* разработан Capybara для испольования в RSpec и обычно используются для проверки существования селектора на выходе отрендеренного действием контроллера. 

Тест провалится с примерно такой ошибкой:

```ruby
Failure/Error: expect(response).to
      have_selector("#project_#{on_schedule.id} .on_schedule")
      expected to find css "#project_980190963 .on_schedule"
      but there were no matches
```

Небольшие изменения в шаблоне *index* и наш тест пройдет - нужно лишь изменить имя ячейки проекта используя хелпер *name_with_status*.

```erb
<!-- app/views/projects/index.html.erb -->
<h1>All Projects</h1>
<table>
  <thead>
    <tr>
      <td>Project Name</td>
      <td>Total Project Size</td>
    </tr>
  </thead>
  <tbody>
    <% @projects.each do |project| %>
      <tr class="project-row" id="<%= dom_id(project) %>">
        <td class="name"><%= name_with_status(project) %></td>
        <td class="total-size"><%= project.total_size %></td>
      </tr>
    <% end %>
  </tbody>
</table>
```

Использовать *have_selector* можно несколькими способами. Аргументом может быть только элемент, такой как *div*, или же элемент плюс класс или ID, например *div.hidden*. Так же можно использовать квадратные скобки для определения атрибутов HTML: *input[name='email']*. Более детально в документации Capybara. 

> Принцип 21. **При тестировании элементов представления желательно проверять DOM классы, нежели текст или имена элементов, которые могут меняться при смене дизайна.**

Так же можно добавлять в сличитель *have_selector* необязательный аргумент *text*, значением которого должна быть строка или регулярное выражение. 

```ruby
have_selector("#project_#{on_schedule.id} .on_schedule", text: "On Schedule")
```

Так же можно добавлять аргумент *count*, который принимает значение integer. В таком случает *have_selector* пройдет проверку только, если количество совпадений будет равно значению аргумента *count*. Так же можно указать диапазон с помощью *between* или же обозначить *maximum* или *minimum*.

```ruby
have_selector("#project_#{on_schedule.id} .on_schedule", count: 1)
```

Бывает полезно проверить, что элемент не отображается на странице, как например кнопка администратора. Capybara предоставляет для этого *have_no_selector*, который лучше уживается с асинхронным яваскриптом, нежели *not_to have_selector*.

<div id='user-content-chapter-8.7'/></div>
### Презентеры (Presenters)

Если в ваших хелперах много логики, я рекомендую переместить логику в объекты презентеров. Это особенно оправдано, если ряд хелперов принимают одинаковый аргумент.

Нет ничего сложного в тестировани презентеров в Rails. Зачастую я использую класс SimpleDelegator, а для большей структурированности можно подключить gem *drapper*.

```ruby
# app/presenters/project_presenter.rb
class ProjectPresenter < SimpleDelegator

  def self.from_project_list(*projects) 
    projects.flatten.map { |project| ProjectPresenter.new(project) }
  end

  def initialize(project) 
    super
  end

  def name_with_status 
    dom_class = on_schedule? ? 'on_schedule' : 'behind_schedule'
    "<span class='#{dom_class}'>#{name}</span>"
  end

end
```

Главное действие тут initialize. Все, что нам нужно сделать, так это вызвать *super* и *SimpleDelegator* обо всем позаботится: если он получит непонятно сообщения, то автоматически делегирует его объекту переданному конструктору. На практике это означает, что мы рассматриваем презентер как экземпляр подлинного объекта. Плюс презентер включает все методы, которые мы к нему добавили. 

Т.к. методы *on_schedule?* или *name* сейчас делегированы, нет нужны в явном вызове объекта project как получателя: мы можем просто использовать *on_schedule?* вместо *project.on_schedule?*. Тем не менее, с тех пока как мы не внутри хелпера, у нас нет доступа к методу *content_tag* и мы вынуждены писать HTML вручную. 

В итоге вверху класса у нас метод, который принимает список экземпляров Project и конвертирует их в презентеры. Аргумент **projects* вместе с *projects.flatten* позволяет методу быть вызванным как для массива *ProjectPresenter.from_project_list([p1, p2])*, так и для обычного списка проектов *ProjectPresenter.from_project_list(p1, p2)*.

Тест презентера довольно легкий:

```ruby
# spec/presenters/project_presenter_spec.rb
require 'rails_helper'

describe ProjectPresenter do
  let(:project) { instance_double(Project, name: "Project Runway") }
  let(:presenter) { ProjectPresenter.new(project) }

  it "handles name with on time status" do
    allow(project).to receive(:on_schedule?).and_return(true)
    expect(presenter.name_with_status).to eq(
        "<span class='on_schedule'>Project Runway</span>")
  end

  it "handles name with behind schedule status" do
    allow(project).to receive(:on_schedule?).and_return(false)
    expect(presenter.name_with_status).to eq(
        "<span class='behind_schedule'>Project Runway</span>")
  end
end
```

Т.к. у класса презентера нет зависимостей от Rails, мы можем написать тест, в котором так же не будет зависимостей от Rails. Мы заменили настоящий объект *project* подделкой. 

Т.к. у теста нет зависимостей от Rails, мы не нуждаемся в его окружении - и приложив немного усилий можем заменить *require 'rails_helper'* вверху файлы на *require 'spec_helper'*. То есть мы можем запускать тест без запуска Rails, что приведет к повышению скорости выполнения теста.

<div id='user-content-chapter-8.8'/></div>
### Тестирование рассыльщиков (Mailers)

Тестирование рассыльщиков в Rails включает две части: проверка отправки письма после определенного действия и проверка содержимого письма. Отправка письма обычно проверяется тесте контроллера или интеграционном тесте, в то время как у проверка содержимого письма много общего с тестированием представлений. Несколько косвенный характер ActionMailer в Rails делает тестирование писем менее очевидным, чем должно быть, но это не сложно. Мы так же рассмотрим стороннюю библотеку для облегчения задачи.

К примеру, мы хотим, чтоб отправлялось письмо, когда задание обозначается выполненным. Давайте сфокусируемся на действии контроллера, которое обрабатывает отмечание задания выполненным. 

Подумаем, о том, что нам нужно:
 - Дано: Нам нужно задание, которое изначально невыполнено;
 - Условия: Действие теста это действие контроллера. В RESTful Rails интерфейсе это действие будет *TasksController#update*. Действие контроллера применяет параметр *completed: true*.
 - Далее: Задание обновляется и письмо отправляется.

> Принцип 22. При тестировании логического(boolean) условия пишите тесты для обоих случаев.

```ruby
# spec/controllers/tasks_controller_spec.rb
require 'rails_helper'

RSpec.describe TasksController, :type => :controller do
  before(:example) do
    ActionMailer::Base.deliveries.clear 
  end

  describe "PATCH update" do
    let(:task) { Task.create!(title: "Write section on testing mailers", size: 2) }
    it "does not send an email if a task is not completed" do
      patch :update, id: task.id, task: {size: 3}
      expect(ActionMailer::Base.deliveries.size).to eq(0) 
    end
  end
end
```

Мы используем блок *before(:example)* и очищаем объект *ActionMailer::Base.deliveries* для того, чтобы быть уверенным, что структура содержащая рассылку очищена. Так же нужно удостовериться, что файл *config/environments/test.rb* содержит строку *config.action_mailer.delivery_method = :test*. 

Тест пройдет со следующим методом контроллера (плюс чистый шаблон в *app/views/tasks/edit.html.erb*):

```ruby
# app/controllers/tasks_controller.rb
class TasksController < ApplicationController
  def update
    @task = Task.find(params[:id])
    if @task.update_attributes(params[:task].permit(:size))
      redirect_to @task, notice: "'project was successfully updated.'"
    else
      render action: 'edit'
    end
  end

  def show
    @task = Task.find(params[:id])
  end
end
```

А вот тест с выполненным заданием, который проверяет поведение рассылки.

```ruby
# spec/controllers/tasks_controller_spec.rb
    # ...
    it "sends email when task is completed" do
      patch :update, id: task.id, task: {size: 3, completed: true}
      task.reload  
      expect(task.completed_at).to be_present
      expect(ActionMailer::Base.deliveries.size).to eq(1)
      email = ActionMailer::Base.deliveries.first 
      expect(email.subject).to eq("A task has been completed")
      expect(email.to).to eq(["monitor@tasks.com"])
      expect(email.body.to_s).to match(/Write section on testing mailers/)
    end
    # ...
```

Мы имитировал вызов метода *update* на этот раз с аттрибутом *completed*. Далее мы перегрузили объект задания для применения изменений и удостоверились, что атрибут *completed_at* обновился. 

Далее мы перешли к рассыльщику. Удостоверились, что письмо было отослано и проверили его на соответствие темы, получателя и содержания.

Тест провалится. Прежде всего из-за проверки атрибута *completed_at*. По этому внесем изменения в контроллер:

```ruby
# app/controllers/tasks_controller.rb
class TasksController < ApplicationController

  def update
    @task = Task.find(params[:id])
    completed = params[:task].delete(:completed)
    params[:task][:completed_at] = Time.current if completed
    if @task.update_attributes(params[:task].permit(:size, :completed_at))
      TaskMailer.task_completed_email(@task).deliver if completed
      redirect_to @task, notice: "'project was successfully updated.'"
    else
      render action: 'edit'
    end
  end

  def show
    @task = Task.find(params[:id])
  end
end
```

Теперь нам нужен сам рассыльщик. Мы можем сгенерировать его из коммандной строки используй Rails генератор:

```
$ rails generate mailer TaskMailer
create app/mailers/task_mailer.rb
      invoke  erb
      create    app/views/task_mailer
      invoke  rspec
      create    spec/mailers/task_mailer_spec.rb
```

Далее нам нужно изменить рассыльщик: указать задание и определить некоторые значения.

```ruby
# app/mailers/task_mailer.rb
class TaskMailer < ActionMailer::Base
  default from: "from@example.com"

  def task_completed_email(task)
    @task = task
    mail(to: "monitor@tasks.com", subject: "A task has been completed")
  end
end
```

И шаблон:

```erb
<!-- app/views/task_mailer/task_completed_email.text.erb -->
The task <%= @task.title %> was completed at <%= @task.completed_at.to_s %>

Thanks,

The Management
```

И тесты пройдут проверку. 

Внешняя библиотека *email-spec* предоставляет ряд очень полезных хелперов. В основном она выполняет эти же тесты, но слегка улучшенным синтаксисом. Она так же предоставляет возможность последовать ссылке в письме обратно на сайт, что очень полезно для приемочных тестов.

<div id='user-content-chapter-8.9'/></div>
### Управление тестами контроллеров и представлений

Тестирование контроллеров и представлений довольно каверзная часть тестирования Rails-приложения. В отличии от тестирования модели (которое стремится быть изолированным) или интеграционного тестирование (которое покрывает весь стек), границы тестирования контроллеров и представлений весьма размыты. В идеале, тесты контроллера должны быть написаны с минимальным взаимодействием с моделью. Сфокусированные тесты представлений возможны, но они сильно перекрываются тестами хелперов, логиков в объектах презентеров и интеграционном тестировании.



<div id='user-content-chapter-10'/></div>
## 10. Интеграционное тестирование с Capybara и Cucumber

Интеграционное тестирование определяет совместное поведение нескольких частей приложения.

Существует три родственных понятия. **Интеграционный** тест - это общее название для теста, который совмещает более одного блока. В Rails, интеграционные тесты часто являются **комплексными**, то есть они охватывают всю систему извне, делая запросы как пользователь и проверяя результат, который был бы виден пользователю. **Приемочный** тест комбинирует комплексный тест с идеей, что тест определяет не только поведение, ожидаемое для программы, но и поведение, правильное на взгляд пользователя или заказчика. Таким образом, любомй приемочный тест интеграционный, но не любой иитеграционный тест приемочный.

В этой главе мы сфокусируемся на интеграционных тестах, который так же и комплексные, предполагая что нам нужны инструменты для имитирования HTTP-запросов и оценки HTTP-ответов.

<div id='user-content-chapter-10.1'/></div>
### Что тестировать в интеграционном тесте

Ранее мы говорили об идее пирамыды тестирования, где среди ваших тестов сравнительно большое количество блочных тестов, которые быстро запускаются и тестируют один небольшой сегмент приложения, и значительно меньшее количество интеграционных тестов, которые в целом проходят более медленно. 

Более наглядно можно представить интеграционные тесты как каркас здания. Без интеграционных тестов нельзя определить, как приложение работает целиком. Без блочных тестов баги полезут из всех щелей. 

> Принцип 23. Имея дело с интеграционными тестами не поддавайтеся искушению использовать их в качестве блочных.

Интеграционный тест уместен, если уникальная точка провала касается взаимодействия двух объектов (или двух методов объекта). Если же уникальная точка провала тест относится к внутренней логике одного и того же объекта, то лучше покрыть ее блочным тестом.

Когда использовать интеграционные тесты:
 - при взаимодействии между контроллером и моделью или другими объектами, которые предоставляют данные;
 - при взаимодействии нескольких действий контроллера, который охватывают общий рабочий поток;
 - при некторых сервисных проблемах включающих взаимодействие пользователя и определенного действия контроллера.

Когда не использовать интеграционный тесты (а использовать блочные):
 - при специальных случаях бизнес-логики, таких как: что случится, если данные отсутствуют или имеют неправильные значения;
 - случаи ошибок, если только это не уникальные случаи;
 - реализация внутренних деталей бизнес-логики.

Две проблемы случаются, когда мы покрываем интеграционными тестами вещи, для которых лучше использовать блочные тесты. Во-первых, скорость. Интеграционные тесты медленнее. Во-вторых, точность. Потому что интеграционные тесты не делают предположений до того как внутренняя логика выполнится и по этому бывает сложно понять в чем проблема.

<div id='user-content-chapter-10.2'/></div>
### Настройка Capybara

Capybara позволяет автоматизированным тестам имитировать пользовательское взаимодействие с браузером. При этом Capybara работает вместе с драйвером, используя Capybara API для определения с какими элементами взаимодействовать. По умолчанию Capybara использует родную библиотеку Ruby, которая не управляет JavaScript взаимодействиями, но может быть для этого настроена, чтоб использовать PhantomJS или Selenium.

#### Capybara и RSpec

Capybara разработана для использования с RSpec и для использования их вместе добавьте Capybara в гемфайл в группу тестирования:

```
gem 'сapybara', group: :testing
```

Так же потребуется добавить следующую строку в *rails_helper.rb* вверху:

```ruby
require 'capybara/rails'
```

#### Capybara и Minitest

Настройка Minitest такая же, только гем другой:

```
gem 'minitest-rails-сapybara', group: :testing
```

Так же потребуется добавить следующую строку в *test_helper.rb* вверху:

```ruby
require 'minitest/rails/capybara'
```

<div id='user-content-chapter-10.3'/></div>
### Тестирование "от общего к частному" (Outside-in)

Процесс, который мы будем использовать для управления тестами Capybara иногда называют тестированием от общего к частому - мы начнем использовать Capybara для написания теста от общего и используем этот тест для управления нашими блочными тестами. Так же, как и TDD используем провальные блочные тесты для управления кодом, тестирование от общего к частному использует провальный приемочный тест (или провальную строку приемочного теста) для управления созданием блочных тестов.

Мы собираемся создать новую функцию в Rails-приложении.

Давайте пройдемся по пунктам.

1. Написать комплексный тест, который показывает пользовательское взаимодействие с новой функцией. Тест должен указывать данные, иметь одну или более пользовательский взаимодействий и проверять HTML-ответы, чтоб определить, что взаимодействия проходят, как ожидалось. Тест должен быть общим, безошибочным, взаимодействием функции. Прежде процесс начнется, было бы хорошо пройтись по контроллерам и представлениям пытаясь понять, как должно выглядеть взаимодействие пользователя. Можете даже написать основную часть функции. Но вы должны быть готовы переписать этот код как только тестирование начнется.

2. Начать запуск тестов. В довольно зрелом приложении первые несколько шагов уже пройдены. Вы часто будете добавлять новые функции к существующей странице, по этому шаги, в которых подготовливаются данные, пользователи логинятся и загружаются существующие страницы, должны работать.

3. Дойдет до провала теста. Первые провалы в интеграционном тесте зачастую незначительны: попытки кликнуть по несуществующей ссылке или заполнить несозданную форму. Они могут быть быстро исправлены без блочных тестов, так как в теории добавлении элементов в представление не является тестируемой логикой.

4. И вот в итоге вы упираетесь в пропасть. Вы достигаете точки, где вы проверяете запросы и при этом множество логики в коде пропущено. Теперь у вас появляется четко определенное задание и время перейти к блочным тестам.

5. Какой именно блочный тест писать, зависит от ситуации. Суть в том, что блочные тесты идут помимо самих интеграционных тестов. 

6. Когда блочные тесты будут готовы, возвращайтесь к интеграционному тест. Возможно он опять упадет, если вы забыли написать часть интеграционной логики. Не проблема: именно для этого и нужны интеграционные тесты.

7. Наконец-то интеграционный тест проходит. Если есть другой значительный случай взаимодействия пользователя с функцией, пишите тест и начинайте заново.

Давайте попробуем пример на практике.

<div id='user-content-chapter-10.4'/></div>
### Использование Capybara

Последний раз оставляя наше приложении мы могли создавать новые проекты. Давайте продолжим и добавим возможность видеть страницу существующего проекта и добавлять к нему задание. И чтоб прибавить немного бэкэнд логики, с которой можно поиграть, давайте установим ситуацию, при которой задания упорядочены и мы хотим подвинуть одно задание выше другого.

#### Написание теста

У этого теста есть несколько разных частей. Давайте на секунду прервемся и составим план:
 - Дано: Нам нужен один существующий проект и хотя бы одно существующее задание в этом проекте для тестирования упорядочивания. Мы вероятно захотим два задания; таким образом мы сможем проверить корректность пользовательского интерфейсадля первой, последней и средней частей списка.
 - Условие/Далее: Пользователь заполняет форму для нового задания и мы проверяем отображение нового задания.
 - Условие/Далее: Пользователь перемещает задание вверх и мы проверяем изменение порядка.

Факт присутствия двух пунктов "Условие/Далее" говорит о том, что желательно сделать два теста, но для простоты объяснений мы сделаем один. Давайте на него взглянем:

```ruby
# spec/features/add_task_spec.rb
require 'rails_helper'

describe "adding a new task" do
  fixtures :all

  it "can add and reorder a task" do
    visit project_path(projects(:bluebook))
    fill_in "Task", with: "Find UFOs"
    select "2", from: "Size"
    click_on "Add Task"
    expect(current_path).to eq(project_path(projects(:bluebook)))
    within("#task_3") do
      expect(page).to have_selector(".name", text: "Find UFOs")
      expect(page).to have_selector(".size", text: "2")
      expect(page).not_to have_selector("a", text: "Down")
      click_on("Up")
    end
    expect(current_path).to eq(project_path(projects(:bluebook)))
    within("#task_2") do
      expect(page).to have_selector(".name", text: "Find UFOs")
    end
  end
end
```

Тест немного длинноват и несвязный. Он так же не полностью тестирует интерфейс пользователя в том смысле, что не проверяет существование всех ссылок "Вверх" и "Вниз". Тест проходит по взаимодействию удобно затрагивая важную часть Capybara API.

Давайте пройдемся по Capybara API, просматривая каждый вызов метода, который мы использовали, а так же изучая сопутствующие методы. Далее мы пройдемся по остальной части процесса и заставим тест пройти.

#### Capybara API: навигация

У Capybara есть метод для навигации по маршрутам приложения и это первая строка в нашем тесте: *visit project_path(projects(:runaway))*. Метод *visit* принимает один аргумент - строку URL (в нашем случае метод маршрутизации, который возвращает строку URL). Маршрут генерируемый методом *visit* это всегда *HTTP GET*. Если хотите имитировать *POST* или любой другой НТТР-метод, рекомендуемым механизмом в Capybara является навигация по ссылки или кнопке формы на странице, которая выполняет жилаемое действие.

#### Capybara API: взаимодействие

После того, как наш тест переходит по URL *project_path*, мы начинаем использовать методы Capybara для взаимодействия с элементами страницы. А именно, мы используем метод *fill_in* для размещений текста в текстовом поле, далее метод *select* для выбора варианта в меню выбора и наконец-то метод *click_on*, чтоб кликнуть на кнопке и отправить форму. У Capybara есть около десяти методов для взаимодействия с элементами DOM.

Capybara очень гибкий в плане выбора элементов. Можно указать любой элемент по его DOM ID. Элементы формы так же могут быть указаны по атрибуту *name*. Элементы формы прикрепленные к тегу *label* могут быть определены по тексту прикрепленного *label*. Элементы, такие как якорные теги HTMl, которые имеют внутренний текст, могут быть указаны по этому тексту. Анкерные теги HTML, телом которого является изображение, могут быть обнаружены по текстовому атрибуту *alt* для изображения. 

Другими словами, если у вас есть следующий HTML-отрывок:

```html
<form>
  <label for="user_email">Email</label>
  <input name="user[email]" id="user_email">
</form>
```

можно использовать Capybara для доступа к форме любым из следующих способов:

```ruby
fill_in("user_email", with: "noel@noelrappin.com")
fill_in("user[email]", with: "noel@noelrappin.com")
fill_in("Email", with: "noel@noelrappin.com")
```

Первый использует DOM ID, второй - имя формы, а третий - текст в *label*. 

По умолчанию Capybara сранивает подмножества, по этому можно так же использовать "em" как сличитель, если хотите. Если подходят более одного элемента, то Capybara выдает ошибку. (Такое поведение характерно для Capybara версии 2.2, старые версии ведут себя по-другому.) Если нужно строгое совпадение, не включая подстроку, передайте параметр *exact:true* любому методу Capybara, который использует локатор.

Какой поиск текста использовать? Зависит от ситуации. Поиск по тексту в *label* наиболее читаемый. Но он так же и самый хрупкий, т.к. этот текст легко может быть изменен. В то же время поиск по DOM ID наименее читаемый, но при этом ID врятле подвергнется изменению.

Список методов Capybara для взаимодействия с формой:

<dl>
  <dt>check(locator)</dt>
  <dd>Поиск чекбокса по <i>locator</i> и его отмечание.</dd>
  <dt>choose(locator)</dt>
  <dd>То же, что и <i>check</i>, только для радиокнопок.</dd>
  <dt>fill_in(locator, with: "text")</dt>
  <dd>Локатор должен найти текствое поле и разместить туда значение из параметра <i>with</i>.</dd>
  <dt>select(value, from: locator)</dt>
  <dd>Поиск меню выбора, которое совпадает с локатором из параметра <i>from</i> и установка его значения значением первого аргумента. </dd>
  <dt>click_on(locator)</dt>
  <dd>Находит якорную ссылку или кнопку по локатору и имитирует на нем клик.</dd>
</dl>

Далее еще несколько методов, которые вы наверное будете использовать реже.

<dl>
  <dt>attach_file(locator, path)</dt>
  <dd>Имитирует прикрепление файла по данному пути к форме, найденной по локатору</dd>
  <dt>click_button(locator); click_link(locator)</dt>
  <dd>Как <i>click_on</i>, только для кнопки или ссылки.</dd>
  <dt>uncheck(locator)</dt>
  <dd>Снимает статус "отмечено" с чекбокса, найденного по локатору</dd>
  <dt>unselect(value, from: locator)</dt>
  <dd>Этот метод снимает статус "выбрано" с сэлектбокса, найденного по локатору. Полезен для сэлектбоксов с возможностью выбора нескольких значений.</dd>
</dl>

#### Capybara API: запросы

У Capybara есть несколько методов для запроса имитированной страницы браузера, чтоб проверить наличие на ней разных селекторов. В этом случае синтаксис между Minitest и RSpec будет слегка отличаться. 

Наиболее распространенный метод запроса в Capybara - это сличитель *have_selector* в RSpec и *assert_selector* в Minitest. Они идентичны. По умолчанию Capybara ищет CSS-селектор, совпадающий с аргументом метода запроса, используя # для DOM ID и точку (.) для DOM класса аналогично тому, как мы видели в тестах представлений. 

Если нужно указать, что данные селектор не находится на странице, в RSpec можно использовать эквивалентные методы *not_to have_selector* или *have_no_selector*. В Minitest нужно использовать *assert_no_selector*. 

Сначала наш тест использует *have_selector* чтоб удостовериться, что элементы *.name* и *.size* присутствуют и совпадают с соответствующими дополнительным аргументами. Все методы Capybara принимают дополнительные аргументы, включая *text* и *count*. *text* принимает строку или регулярное выражение, которое должно совпадать с содержимым выбранного элемента. *count* должен совпадать с количеством элементов на странице.

Так же есть метод *has_link?*, который принимает локатор. 

Наш тест так же использует метод *within*, который принимает селектор в качестве аргумента и блок. По селектору, переданному *within*, будет найдет один элемент. Методы в блоке применимы к содержимому найденного элемента. 

```ruby
within("#task_2") do
  expect(page).to have_selector(".name", text: "Cast the designers")
end
```

Данная часть теста пройдет только если элемент *.name* будет внутри *#task_2*. 

Наиболее полезным методом Capybara, когда что-то не получается, является *save_and_open_page*, который сбрасывает содержимое Capybara DOM во временный файл и открывает этот файл в браузере (для открытия в браузере нужен гем *launchy*). Там не будет картинок или CSS, но и этого обычно достаточно для того, чтоб, к примеру, дать понять, что вы застряли на окне входа, потому что забыли создать авторизованного пользователя.

<div id='user-content-chapter-10.5'/></div>
### Заставляя пройти тест Capybara

Пройдемся по процессу интеграционного теста.

Первая ошибка будет на первой же строчке: *projects(:bluebook)* - это вызов метода испытательного стенда (fixture), который мы еще не определили. Нужно добавить файл испытательного стенда в директорую спека:

```yml
# spec/fixtures/projects.yml

one:
  name: MyString
  due_date: 2013-11-10

two:
  name: MyString
  due_date: 2013-11-10

bluebook:
  name: Project Blue Book
  due_date: <%= 6.months.from_now %>
```

Пока мы там, так же добавим проекту пару заданий для возможности сортировки. Так же нужно добавить *belongs_to :project* в файл *app/models/task.rb*.

```yml
# spec/fixtures/tasks.yml

one:
  project: bluebook
  title: Hunt the aliens
  size: 1
  completed_at:

two:
  project: bluebook
  title: Write a book
  size: 1
  completed_at:
```

Мне нравится использовать испытательные стенды для интреграционных тестов, потому что это быстрее, чем создавать объекты заново для каждого теста. 

Следующим провалом будет отсутствие метода show в ProjectsController. Этот метод достаточно прост и наверное не нуждается в дополнительном тестировании:

```ruby
# app/controllers/projects_controller.rb

def show
  @project = Project.find(params[:id])
end
```

Нам так же нужен шаблон. Нужна таблица для задач, а так же форма для создания новой задачи.

```erb
<!-- app/views/projects/show.html.erb -->

<h2>Project: <%= @project.name %></h2>

<h3>Existing Tasks:</h3>

<table>
  <thead>
    <tr>Name</tr>
    <tr>Size</tr>
  </thead>
  <tbody>
    <% @project.tasks.each do |task| %>
      <tr>
        <td class="name"><%= task.title %></td>
        <td class="size"><%= task.size %></td>
        <td class="completed"><%= task.completed_at.to_s %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<h3>New Task</h3>

<%= form_for Task.new(project_id: @project.id) do |f| %>
  <%= f.hidden_field :project_id %>
  <%= f.label :title, "Task" %>
  <%= f.text_field :title %>
  <%= f.label :size %>
  <%= f.select :size, [1, 2, 3, 4, 5] %>
  <%= f.submit "Add Task" %>
<% end %>
```

На данном этапе тест будет падать, потому что нет метода *create* в *TasksController*. Это значит, что нам нужно создать новую логику. 

```ruby
# app/controllers/tasks_controller.rb

def create
  @task = Task.new(
      params[:task].permit(:project_id, :title, :size))
  redirect_to @task.project
end
```

Следующая ошибка - *Capybara:ElementNotFound: Unable to find css "#task_3"*.

В исходном тесте Capybara мы определяем каждый ряд по порядку заданий, по этому три ряда будут иметь DOM ID: *task_1*, *task_2* и *task_3*. Но у нас не только нет этих ID в шаблоне, но и механизма упорядочивания самих заданий тоже нет. 

Мы хотим чтоб: а) у каждого задания был номер в упорядоченном списке, б) проект отображал задания упорядоченно и в) новые задания попадали в конец списка.

Для решения первой задачи мы дадим заданиям номер по порядку с помощью миграции Rails: 

```
$ rails g migration add_order_to_tasks
```

Добавим новый атрибут *project_order*, чтоб не путать с SQL-оператором *order*:

```ruby
# db/migrate/***_add_order_to_tasks.rb

class AddOrderToTasks < ActiveRecord::Migration
  def change
    add_column :tasks, :project_order, :integer
  end
end
```

```
$ rake db:migrate
```

Мы может заставить проекты автоматически возвращать задания в правильном порядке используя ActiveRecord и изменив объявления связей на:

```ruby
has_many :tasks, -> { order "project_order ASC" }
```

Тест нам не нужен, т.к. это чать фреймворка.

Для работы теста нам так же нужно добавить номер порядка в испытательные стенды в *spec/fixtures/tasks.yml*. Первому объекту дадим *project_order: 1*, второму - *project_order: 2*.

Часть, где проект показывает новые задания и порядок добавляет некоторую логику. Есть несколько вариантов реализации. Мы можем поместить логику в колбэк модели *Task*, который будет автоматически вызываться на сохрании задания; можем поместить ее в метод модели *Project* и запрашивать проект на номер порядка следующего задания; или можем создать фабрику объектов Task подобную CreatesProject, которую мы создавали ранее.

Для простоты, создадим метод в модели *Project*, который будем вызывать при создании задания. Напишем некоторые модульные тесты:

```ruby
# spec/models/project_spec.rb

describe "task order" do
  let(:project) { project = Project.create(name: "Project") }

  it "gives me the order of the first task in an empty project" do
    expect(project.next_task_order).to eq(1)
  end

  
  it "gives me the order of the next task in a project" do
    project.tasks.create(project_order: 3)
    expect(project.next_task_order).to eq(4)
  end
end
```

Эти тесты пройдут со следующим кодом:

```ruby
# app/models/project.rb

def next_task_order
  return 1 if tasks.empty?
  (tasks.last.project_order || tasks.size) + 1
end
```

Теперь нужно это интегрировать. Прежде всего нужно вызывать новый метод в контроллере:

```ruby
# app/controllers/tasks_controller.rb

def create
  @project = Project.find(params[:task][:project_id])
  @project.tasks.create(title: params[:task][:title],
      size: params[:task][:size],
      project_order: @project.next_task_order)
  redirect_to @project
end
```

Теперь в шаблоне *app/views/projects/show.html.erb* мы заменим ряд таблицы следующим:

```erb
<tr id="task_<%= task.project_order %>">
```

Это предоставим нам наш селектор *task_3*.

Следующей ошибкой будет *Unable to find link or button with text "Up"*, которая означает что логика обновления отсутствует.

Какая логика нужна? И как мы можем написать для нее тест?

Мы хотим кнопку "Up" для всех заданий, кроме первого, и кнопку "Down" для всех, кроме последнего. То есть мы должны уметь определять, является ли задания первым или последним. Это тестируемо:

```ruby
# spec/models/task_spec.rb

describe "order" do
  let!(:project) { Project.create!(name: "Project") }
  let!(:first) { project.tasks.create!(project_order: 1) }
  let!(:second) { project.tasks.create!(project_order: 2) }
  let!(:third) { project.tasks.create!(project_order: 3) }

  it "finds that a task is first or last" do
    expect(first). to be_first_in_project
    expect(first).not_to be_last_in_project
    expect(second).not_to be_first_in_project
    expect(second).not_to be_last_in_project
    expect(third).not_to be_first_in_project
    expect(third). to be_last_in_project
  end
end
```

Тут больше проверок, чем я обычно помещаю в одном тесте, но они очень тесто связаны, по этому я решил, что они будут лучше всего читаться в одной группе.

Тест пройдет при:

```ruby
# app/models/task.rb

def first_in_project?
  return false unless project
  project.tasks.first == self
end

def last_in_project?
  return false unless project
  project.tasks.last == self
end
```

Теперь нужно поместить эту логику в шаблон представления, добавив немного кода в цикл в *app/views/projects/show.html.erb*. Есть два варианта: направлять ссылку на метод *update* контроллера *TasksController*, который уже существует и его нужно менять, или же создавать новые действия *up* и *down* в контроллере. 

Выберем второе. Сначала определим маршруты:

```ruby
# config/routes.rb

Gatherer::Application.routes.draw do
  resources :tasks do
    member do
      patch :up
      patch :down
    end
  end

  resources :projects
end
```

Далее дополним шаблона *app/views/projects/show.html.erb*:

```erb
<td>
  <% unless task.first_in_project? %>
    <%= link_to "Up", up_task_path(task.id), method: :patch %>
  <% end %>
  <% unless task.last_in_project? %>
    <%= link_to "Down", down_task_path(task.id), method: :patch %>
  <% end %>
</td>
```

Далее нужна возможность менять порядок задания с одним из его соседов, которая предпологает возможность найти этих соседов. 

```ruby
# spec/models/task_spec.rb
describe "order" do
# ...
  it "can move up" do
    expect(second.previous_task).to eq(first)
    second.move_up
    expect(first.reload.project_order).to eq(2)
    expect(second.reload.project_order).to eq(1)
  end

  it "can move down" do
    expect(second.next_task).to eq(third)
    second.move_down
    expect(third.reload.project_order).to eq(2)
    expect(second.reload.project_order).to eq(3)
  end
end
```

А вот набор методов для прохождения этих тестов:

```ruby
# app/models/task.rb

def my_place_in_project
  project.tasks.index(self)
end

def previous_task
  project.tasks[my_place_in_project - 1]
end

def next_task
  project.tasks[my_place_in_project + 1]
end

def swap_order_with(other)
  other.project_order, self.project_order =
      self.project_order, other.project_order
  self.save
  other.save
end

def move_up
  swap_order_with(previous_task)
end

def move_down
  swap_order_with(next_task)
end
```

Осталось совсем чуть-чуть. Нужно лишь дополнить контроллер:

```ruby
# app/controllers/tasks_controller.rb

def up
  @task = Task.find(params[:id])
  @task.move_up
  redirect_to @task.project
end

def down
  @task = Task.find(params[:id])
  @task.move_down
  redirect_to @task.project
end
```

И... теперь интеграционный тест проходит успешно, все тесты зеленые. Ура.

<div id='user-content-chapter-10.6'/></div>
### Ретроспектива

Написание интеграционных тестов дает нам ряд приемуществ:
 - Структурированность; мы знаем, что должно быть сделано следующим. 
 - Интеграционный тест доказывает, что все наши блочные тесты работают как одно целое. Блочные тесты позволяют сосредоточиться на деталях, а интеграционные помогают охватить все картину целиком.
 - Не смотря на то, что интеграционные тесты медленные по сравнению с блочными тестами, они все равно значительно выигрывают у ручного тестирования в браузере.

Оглядываясь назад на первоначальный тест, можно сказать, что он был длинным и громодзким. Можно вернуться назад и разделить связанные строки на их собственные методы.

А можно попробовать Cucumber.

<div id='user-content-chapter-10.7'/></div>
### Пробуем Cucumber

Cucumber - это инструмент для написания приемочных и интеграционных тестов на простом языке. Я предпочитаю смотреть на Cucumber как на инструмент, который делает две вещи. Во-первых, он позволяет структурировать интеграционные тесты. Во-вторых, он дает возможность описать требуемое поведение системы без использования кода.

<div id='user-content-chapter-10.8'/></div>
### Настройка Cucumber

Для установки Cucumber нам потребуется два гема в *Gemfile*:

```ruby
group :development, :test do
  gem 'cucumber-rails', require: false  # The false prevents warning
  gem 'database_cleaner'
end
```

И *bundle install*.

Строго говоря, *database_cleaner* не обязателен, но полезен. В момент написания книги мы говорим о Cucumber версии 1.3.15 и *cucumber-rails* версии 1.4.1.

Для установки Cucumber есть генератор: 

```
$ rails generate cucumber:install
```

Он создаст файл *config/cucumber.yml* для параметров среды выполнения, сам скрипт командной строки *cucumber*, *rake* task, папку *features* с подпапками *step_definitions* и *support*, а так же файл *features/support/env.rb* (аналог *test_helper.rb*). Так же он изменяет файл *database.yml* добавляя окружение *cucumber*, которое копирует тестовое окружение. У Cucumber есть некоторые дополнительные параметры конфигурации, увидеть которые можно с помощью команды *rails generate cucumber:install --help*. 

<div id='user-content-chapter-10.9'/></div>
### Написание функций Cucumber

В Cucumber тесты пишут сериями шагов, используя очень минималистичный язык под названием Gherkin. Единичный тест Cucumber называется сценарием, а группа тестов - функцией (feature). 

Давайте возьмем интеграционный тест Capybara из последней части и конвертируем его в тест Cucumber. Файлы функций Cucumber распологаются в директории features и заканчиваются на .feature.

```feature
# features/add_task.feature

Feature: Adding a task

  Background:
    Given a project

  Scenario: I can add and change priority of a new task
    When I visit the project page
    And I complete the new task form
    Then I am back on the project page
    And I see the new task is last in the list
    When I click to move the new task up
    Then I am back on the project page
    And the new task is in the middle of the list
```

У этого файла три части. Объявление функции *Feature* вверху. Файл должен иметь одно объявление, но в самом объявлении можно писать что угодно, оно исключительно для людей. Язык Gherkin чуствителен к пробелам, по этому все, что идет после объявления функции, должно быть с отступом.

Следующая часть - *Background*, которая необязательна. В Cucumber *Background* похож на *setup* в Minitest или *before* в RSpec, указывая код, который запускается для инициализации каждого теста. В нашем случае, с одним сценарием не обязательно иметь *Background*, но в случае с несколькими сценариями, *Background* может быть общий для всех. 

После *Background* идет *Scenario*, где расположен сам тест. Как *Background*, так и *Scenario* состоят из шагов. В Cucumber шаг обычно состоит из одного из слов *Given*, *When* или *Then*. Так же можно начинать строку со слов *And* или *But* для читабельности. 

Различие между *Given*, *When* и *Then* для людей. Cucumber не требует соблюдения определенного порядка в шагах. 

Сценарий выполняется командой *cucumber* или с указанием файла *cucumber features/add_task.feature*. На выходе имеем две части. В первой листинг по выполнению, который начинается примерно так:

```
Background: # features/add_task.feature:3
    Given a project # features/add_task.feature:4
      Undefined step: "a project" (Cucumber::Undefined)
      features/add_task.feature:4:in `Given a project'

Scenario: I can add and change priority of a new task
                        # features/add_task.feature:6
    When I visit the project page
                        # features/add_task.feature:7
      Undefined step: "I visit the project page" (Cucumber::Undefined)
      features/add_task.feature:7:in `When I visit the project page'
```

Тут не видно, но весь текст, кроме строк с *Background* и *Scenario* будет желтым.

Когда запускается сценарий, Cucumber пытается запустить каждый шаг по его определению. В данном выводе Cucumber сообщает номера строк, которые пытается запустить и что эти шаги не определены. Мы и вправду их не определили. 

Далее нам сообщают, что у нас один сценарий с восемью шагами, из которых один сценарий и 8 шагов не определены. Cucumber добавляет дополнительный вывод в терминал, который начинается примерно так:

```
You can implement step definitions for undefined steps with these snippets:

Given(/^a project$/) do
  pending # express the regexp above with the code you wish you had
end

When(/^I visit the project page$/) do
  pending # express the regexp above with the code you wish you had
end
```

Этот вывод продолжается для всех неопределенных шагов. Cucumber нам очень помогает тут, давая образцы для каждого неопределенного шага, которые можно вставить в редактор и заполнить. 

Так и сделаем. Возьмем все эти блоки и скопируем в файл *features/step_definitions/add_task_steps.rb*. Сделав это, перезапустим Cucumber:

```
Background: # features/add_task.feature:3
    Given a project # features/step_definitions/add_task_steps.rb:1
      TODO (Cucumber::Pending)
      ./features/step_definitions/add_task_steps.rb:2:in `/^a project$/'
      features/add_task.feature:4:in `Given a project'

  Scenario: I can add and change priority of a new task
            # features/add_task.feature:6
    When I visit the project page
            # features/step_definitions/add_task_steps.rb:5
    And I complete the new task form
            # features/step_definitions/add_task_steps.rb:9
    Then I am back on the project page
            # features/step_definitions/add_task_steps.rb:13
    And I see the new task is last in the list
            # features/step_definitions/add_task_steps.rb:17
    When I click to move the new task up
            # features/step_definitions/add_task_steps.rb:21
    Then I am back on the project page
            # features/step_definitions/add_task_steps.rb:13
    And the new task is in the middle of the list
            # features/step_definitions/add_task_steps.rb:25
```

Верхние строки желтые, а строки под *Scenario* - голубые. Cucumber останавливает тест на первом же ожидающем шаге (pending) и обозначает каждый последующий шаг как пропущенный.

Пора сказать Cucumber, что нужно делать на каждой шаге.

<div id='user-content-chapter-10.10'/></div>
### Написание шагов Cucumber

Когда Cucumber получает шаг вроде *Given a project*, он ищет соответствующее определение по всем файлам в директории *step_definitions*. Что это значит? Посмотрим еще раз на шаблон для данного шага:

```ruby
Given(/^a project$/) do
  pending
end
```

Первая строка определения - это одно из тех слов *Given/When/Then* (неважно какое именно) с последующим регулярным выражением. Cucumber сверяет шаг с определением. То есть, когда он видит шаг *Given a project*, то запускает код внутри блока с соответствующим определением шага. Если Cucumber находит более одного совпадающего шага, то выводит ошибку.

Внутри определения шага можно писать любой код Ruby. Переменные экземпляров объявленные в одном определении шага будут доступны в последующих шагах того же теста. Будьте внимательны с переменными экземпляров, не всегда легко сказать, какие переменные существуют из предыдущих шагов, или какое значение им присвоено. Cucumber воспринимает методы Capybara и сличители RSpec (если конечно RSpec установлен). Методы, объявленные в любом определении шага будут доступны в любом определении шага. 

По умолчанию, Cucumber не понимает Minitest. Если хотите использовать утверждения (assertions) Minitest, нужно разместить следующий код в *features/support*:

```ruby
# features/support/minitest.rb

require 'minitest'
module MiniTestAssertions
  def self.extended(base)
    base.extend(MiniTest::Assertions)
    base.assertions = 0
  end

  attr_accessor :assertions
end
World(MiniTestAssertions)
```

*World* в последней строке это глобальный конфигурационный объект Cucumber. Передавая ему имя модуля мы расширяем *World* этим модулем, вызывая метод *extended*, который вставляет утверждения (assertions) Minitest в Cucumber. Этот параграф можно проигнорировать и просто использовать сличители RSpec. 

В принципе наш интеграционный тест уже готов, нам только нужно разделить его на куски.

```ruby
# features/step_definitions/add_task_steps.rb

Given(/^a project$/) do
  @project = Project.create(name: "Bluebook")
  @project.tasks.create(title: "Hunt the Aliens", size: 1, project_order: 1)
  @project.tasks.create(title: "Write a book", size: 1, project_order: 2)
end
#

When(/^I visit the project page$/) do
  visit project_path(@project)
end

When(/^I complete the new task form$/) do
  fill_in "Task", with: "Find UFOs"
  select "2", from: "Size"
  click_on "Add Task"
end

Then(/^I am back on the project page$/) do
  expect(current_path).to eq(project_path(@project))
end

Then(/^I see the new task is last in the list$/) do
  within("#task_3") do
    expect(page).to have_selector(".name", text: "Find UFOs")
    expect(page).to have_selector(".size", text: "2")
    expect(page).to have_no_selector("a", text: "Down")
  end
end

When(/^I click to move the new task up$/) do
  within("#task_3") do
    click_on("Up")
  end
end

Then(/^the new task is in the middle of the list$/) do
  within("#task_2") do
    expect(page).to have_selector(".name", text: "Find UFOs")
  end
end
```

В изначальном тесты мы определяли проекты используя испытательные стенды. В тесте Cucumber мы явно создаем *@project* и его задание в шаге *Given a project*. По умолчанию Cucumber не использует испытательные стенды. Хотя Cucumber можно научить понимать испытательные стенды, это отдельный разговор, прямо сейчас нам это не нужно. 

<div id='user-content-chapter-10.11'/></div>
### Более продвинутый Cucumber

Cucumber обладает широкими дополнительными возможностями при сравнении шагов с их определениями. В общем и целом, сообщество Cucumber пришло к выводу, что большинство из этих возможносте не стоит часто использовать или не стоит использовать вовсе.

Ранее я ссылался на идею о том, что определения шагов должны быть регулярными выражениями, а не строками. Это позволит применять одно определения шага для нескольких строк. 

В нашем первоначальном шаге мы прописывали имя проекта внутри определения шага. Но если мы захотим прописывать имя проекта в функции Cucumber, можно писать определение шага следующим образом:

```ruby
Given /^a project named "(.*)"$/ do |project_name|
  @project = Project.create!(name: project_name)
end
```

Под это определение будут подходить шаги, подобны этим:

```feature
Given a project named "Rails 4 Test Prescriptions"
Given a project named "Evil Master Plan"
```

В каждом случае определение шага будет создавать проект с данным именем. 

В плане ввода данных в файле функции Cucumber можно пойти даже дальше. Cucumber позволяет прилагать таблицу данных к шагу. 

Для создания таблицы нужно использовать что-то вроде синтаксиса таблицы Markdown. В файле функции это должно выглядеть примерно так:

```feature
Given the following users:
    | login| email            | password| password_confirmation|
    | alpha| alpha@example.com| alpha1  | alpha1               |
    | beta | beta@example.com | beta12  | beta12               |
```

Строка шага с таблицей должна заканчиваться двоеточием. Для разграничения записей используется вертикальная черта.

Когда Cucumber сверяет определение шага с шагом с таблицей, таблица становится аргументом для блока определения шага - если есть другие совпадения по регулярным выражениям, то таблица становится последним аргументом. Аргумент является специальным типом данных Cucumber и есть несколько вариантов взаимодействия с ним. Чаще всего этот аргумент представляют в виде хеша:

```ruby
Given /^the following users$/ do |user_data|
  User.create!(user_data.hashes)
end
```

Что-то подобное можно делать с большим строковым литералом:

```feature
Given I have typed the following
  """
  some big amount of text
  """
```

Текст внутри тройных кавычек будет передан блоку определения шага в качестве последнего аргумента. 

Таблицы и строковые литералы (сценарии) можно совмещать:

```feature
Scenario Outline: Users get created
  Given I go to the login page
  When I type <login> in the login field
  And I type <password> in the password field
  Then I am logged in
Examples:
  | login| email            | password| password_confirmation|
  | alpha| alpha@example.com| alpha1  | alpha1               |
  | beta | beta@example.com | beta12  | beta12               |
```

Сценарий запускается для каждой строки таблицы и данные из таблицы подставляются в сами шаги.

Простые определения шагов делают Cucumber более управляемым. Помещая много кода (данные, имена атрибутов, CSS-селекторы) в файлы функции Cucumber, мы усложняем их. Данные в файлах функций не дают им показать намерения. Какая цель шага *Given a user than has been on the site for 2 months?*. Сложно сказать. Шаг *Given a user than has been on the site long enough to be trusted* более красноречив и объясняет зачем он вообще существует. 

<div id='user-content-chapter-10.12'/></div>
### Стоит ли Cucumber того?



<div id='user-content-chapter-10.13'/></div>
### Заглядывая вперед