# Основные приципы тестирования в Rails 4
Конспект по книги Rails 4 Test Prescriptions by Noel Rappin

## Содержание

1. Введение
2. Основы разработки через тестирование
3. Тестирование в Rails
4. Как сделать тесты лучше
5. Тестирование моделей
6. Добавление данных в тесты
7. Использование подделок: фиктивные объекты и заглушки
8. [**Тестирование контроллеров и представлений**](#user-content-chapter-8)
  * [Тестирование контроллеров](#user-content-chapter-8.1)
  * [Имитирование запросов в тестах контроллеров](#user-content-chapter-8.2)
  * [Оценка результатов действия контроллера](#user-content-chapter-8.3)
  * [Тестирование маршрутов](#user-content-chapter-8.4)
  * [Тестирование вспомагательных методов (хелперов)](#user-content-chapter-8.5)
  * [Тестирование представлений](#user-content-chapter-8.6)
  * [Презентеры (Presenters)](#user-content-chapter-8.7)
  * [Тестирование рассыльщиков (Mailers)](#user-content-chapter-8.8)
  * [Управление тестами контроллеров и представлений](#user-content-chapter-8.9)
9. Minitest
10. [**Интеграционное тестирование с Capybara и Cucumber**](#user-content-chapter-10)
  * [Что тестировать в интеграционном тесте](#user-content-chapter-10.1)
  * [Настройка Capybara](#user-content-chapter-10.2)
  * [Тестирование "от общего к частному" (Outside-in)](#user-content-chapter-10.3)
  * [Использование Capybara](#user-content-chapter-10.4)
  * [Заставляя пройти тест Capybara](#user-content-chapter-10.5)
  * [Ретроспектива](#user-content-chapter-10.6)
  * [Пробуем Cucumber](#user-content-chapter-10.7)
  * [Настройка Cucumber](#user-content-chapter-10.8)
  * [Написание функций Cucumber](#user-content-chapter-10.9)
  * [Шаги написания теств с Cucumber](#user-content-chapter-10.10)
  * [Продвинутый Cucumber](#user-content-chapter-10.11)
  * [Стоит ли Cucumber того?](#user-content-chapter-10.12)
  * [Заглядывая вперед](#user-content-chapter-10.13)

<div id='user-content-chapter-8'/></div>
## 8. Тестирование контроллеров и представлений

<div id='user-content-chapter-8.1'/></div>
### Тестирование контроллеров

```ruby
# spec/controllers/projects_controller_spec.rb
require 'rails_helper'

RSpec.describe ProjectsController, type: controller do
  describe "POST create" do
    post :create, project: {name: "Runaway", tasks: "Start something:2"}
    expect(response).to redirect_to(projects_path)
    expect(assigns(:action).project.name).to eq("Runaway")
  end
end
```

Это простой пример теста контроллера. Теста контроллера обычно состоит из 3-х частей:
 1. Тест контроллера может создать данные для тестирования (в тесте сверху мы не нуждаемся в данных, но мы увидим их в следующих примерах тестов);
 2. Выполнения действия: *post :create, project: {name: "Runaway", ...}*;
 3. Предположения отностительно поведения контроллера.

#### Что тестировать в контроллерах

> Принцип 20. Тест контроллера должен тестировать только поведение контроллера. **Тест контроллера не должен падать из-за проблем модели.**

Тест контроллера должен достигнуть одну или более из следующих целей:
 - Удостовериться, что обычный пользовательский запрос запускает вызов ожидаемой модели и отправляет нужные данные на представление;
 - Удостовериться, что неправильный запрос пользователя обрабатывается правильно (что значит "правильно", зависит от приложения);
 - Проверить сервисы, такие как требования логина или запрет просмотра страниц для заблокированных пользователей и т.д.

<div id='user-content-chapter-8.2'/></div>
### Имитирование запросов в тестах контроллеров

Полный запрос имеет пять аргументов (хотя используются обычно только три):

```ruby
get :show, {id: @task.id}, {user_id: "3", current_project: @project.id.to_s}, {notice: "flash test"}
```

Имя метода *get (delete, head, patch, post or put)* это HTTP-запрос, который имитируется. Проверка маршрутизации таким образом не производится, ее нужно тестировать отдельно.

Первый аргумент - в нашем случае *show* - это действие контроллера, которое вызывается. Второй аргумент - *{id: @task.id}* - это хэш, который становится параметрами в действии контроллера (*params[:id]*). *user: {name: "Noel", email: "noel@noelrappin.com"}* будет соответствовать *params[:user][:name] == "Noel"* в контроллере. 

Все параметры переданные в хэш будут автоматически конвертироваться в строку, по этому можно писать так: *id: 3*.

Если один из аргументов загружаемый файл, можно имитировать зазгрузку хелпером *fixture_file_uploader(filename, mimetype)*:

```ruby
post :create, logo: fixture_file_upload('test/data/logo.png', 'image/png')
```

При использовании сторонних сервисов, таких как Paperclip или CarrierWave, хелперы наверняка будут отличаться. 

Четвертый и пятый аргументы опциональны и используются редко. Четвертый аргумент устанавливает пары ключ/значения для объекта сессии. Пятый представляет Rails флэш-объект.

В тесте контроллера можно получить доступ к объекту запроса через переменную *@request*, а к объекту контроллера через *@controller*. Так же есть объект *@response*. Например, можно получить HTTP-headers через *@request.headers*.

Есть еще один метод действия контроллера: *xml_http_request* (псевдоним *xhr*). Он имитирует классический ajax-запрос и слегка отличается. 

```ruby
it "makes an ajax call" do
  xhr :post, :create, :task => {:id => "3"}
end
```

<div id='user-content-chapter-8.3'/></div>
### Оценка результатов действия контроллера

У теста контроллера есть три вещи, которые можно проверять после действия контроллера:
  1. Возвращается ли ожидаемый НТТР-статус? RSpec предоставляет для этого *response.status* объект и *have_http_status* сличитель (matcher);
  2. Передается ли управление определенному шаблону или выполняется ли перенаправление на действие контроллера? Для проверки есть *render_template* и *redirect_to* сличители.
  3. Устанавливаются ли ожидаемый значения? Для проверки есть специальный хэш-объекты *assigns, cookies, flash and session*.

Зачастую эти проверки комбинируются в одном тесте:
```ruby
it "is a successful index request with no filters" do
  get :index
  expect(response).to have_http_status(:success)
  expect(response).to render_template(:index)
end
```

#### Проверка типа ответа контроллера

| Symbol | HTTP Code Equivalent | Symbol  | HTTP Code Equivalent |
|--------|----------------------|---------|----------------------|
|:success|200-299               |:redirect|300-399               |
|:missing|404                   |:error   |500-599               |

#### Проверяем, какой шаблон рендерится

Сличитель *render_template* используется для определения, передается ли управление от контроллера к определенному шаблону представления. Аргументом является действие контроллера. 

Когда ожидается перенаправления, используется *redirect_to*. Аргументом является все, что Rails может конвертировать в url. Код *redirect_to* уже включает *have_http_status(:redirect)*, по этому дублировать проверку не нужно.

Если аргументом для *redirect_to* является название URL, то проверка пройдет **только** если перенаправляемый URL в точности совпадет с аргументом. Для тестирования Rails предполагает, что хост локального приложения *http://www.example.com*. Если это слишком точно, то можно передавать хэш аргументом для *redirect_to*, в котором указывать *:controller*, *:action* и т.д. 

Тесты Rails контроллеров не повторяют и **не следуют** перенаправлениям. Все проверки данных применимы только к методам до перенаправления. Если нужно следовать перенаправлению, то потребуется сделать интеграционный тест.

#### Проверка данных контроллера

Rails позволяет проверять данные сгенерированные действием контроллера, который тестируется, с . помощью четырех способов: *assigns*, *cookies*, *session* и *flash*. *assigns*, который предоставляет доступ к переменной экземпляра, объявленной в контроллере, используется чаще всего. Типичный пример может выглядеть подобный образом:

```ruby
it 'shows a task' do
  task = Task.create!
  get :show, id: task.id
  expect(response).to have_http_status(:success)
  expect(assigns(:task).id).to eq(task.id)
  expect(session[:previous_page]).to eq("task/show")
end
```

<div id='user-content-chapter-8.4'/></div>
### Тестирование маршрутов

Не смотря на то, что маршрутизация в Rails проста, иногда возникает путаница относительно того, что делает приложение при конвертации от URL к Rails действию. 

RSpec-Rails распологает тесты маршрутизации в директории *spec/routing*. Основной сличитель, используемый для тестирования маршрутов, *route_to*. 

```ruby
# spec/routing/project_routing_spec.rb
require 'rails_helper'

RSpec.describe "project routing" do
  it "routes projects" do
    expect(get: "/projects").to route_to(
      controller: "projects", action: "index")
    expect(post: "/projects").to route_to(
      controller: "projects", action: "create")
    expect(get: "/projects/new").to route_to(
      controller: "projects", action: "new")
    expect(get: "/projects/1").to route_to(
      controller: "projects", action: "show", id: "1")
    expect(get: "/projects/1/edit").to route_to(
      controller: "projects", action: "edit", id: "1")
    expect(patch: "/projects/1").to route_to(
      controller: "projects", action: "update", id: "1")
    expect(delete: "/projects/1").to route_to(
      controller: "projects", action: "destroy", id: "1")
  end
end
```

RSpec так же предоставляет метод *be_routable*, который служит для тестирования маршрутов, которые не показываются.

```ruby
expect(get: "/projects/search/fred").not_to be_routable
```

<div id='user-content-chapter-8.5'/></div>
### Тестирование вспомагательных методов (хелперов)

Вспомагательные модули разработаны для хранения многоразово используемых частей логики представления. Из-за того, что немного сложнее настроить их тестирование, вспомагательные методы часто не тестируются, даже если они содержат значительное количество логики приложения.

Предположим, что мы хотим изменить вид нашего проекта, чтобы отстающие от графика проекты отображались иначе. Мы может сделать это через вспомагательный метод. Я обычно добавляю CSS класс к выводу для обоих проектов: как обычных, так и отстающих. 

Вот тест для этого хелпера:

```ruby
# spec/helpers/projects_helper_spec.rb
require 'rails_helper'

RSpec.describe ProjectsHelper, :type => :helper do
  let(:project) { Project.new(name: "Project Runaway") }

  it "augments with status info" do
    allow(project).to receive(:on_schedule?).and_return(true)
    actual = helper.name_with_status(project)
    expect(actual).to have_selector("span.on_schedule", text: "Project Runaway")
  end
end
```

Этот тест создает проект используя стандартный ActiveRecord *new* метод. Вместо определения тучи задач, которые будут означать, что новый проект идет по графику, мы просто создаем метод-заглушку *on_schedule?*. 

Мы испольуем сличитель *have_selector* для сравнения ожидаемого HTML со сгенерированным. 

Тест будет провален, т.к. мы не определили метод. Давайте определим:

```ruby
# app/helpers/projects_helper.rb
module ProjectsHelper
  
  def name_with_status(project)
    content_tag(:span, project.name, class: 'on_schedule')
  end
end
```

Тест пройдет проверку; теперь добавим второй тест для оставшегося случая:

```ruby
# spec/helpers/projects_helper_spec.rb
it "augments project name with status info when behind schedule" do
  allow(project).to receive(:on_schedule?).and_return(false)
  actual = helper.name_with_status(project)
  expect(actual).to have_selector("span.behind_schedule", text: "Project Runaway")
end
```

И тест пройдет проверку при следующих изменения хелпера:

```ruby
# app/helpers/projects_helper.rb
module ProjectsHelper
  
  def name_with_status(project)
    dom_class = project.on_schedule? ? 'on_schedule' : 'behind_schedule'
    content_tag(:span, project.name, class: dom_class)
  end
end
```

О чем еще нужно беспокоится при тестировании представления, так это использование внутренних методов представлений Rails, таких как *url_for*. Хотя основные вспомагательные методы автоматически загружаются в тестовую среду ActionView, один или пара методов имеют важные зависимости на объекте контроллера и следовательно тесты падают. Выходом является определение метода в тесте через заглушку.

Иногда вспомагательные методы принимают блок, который должен быть ERB текстом. Например:

```ruby
def if_logged_in
  yield if logged_in?
end
```
Данный метод может быть вызван так:
```erb
<% if_logged_in %>
  <%= link_to "logout", logout_path %>
<% end %>
```

Для тестирования хелпера *if_logged_in* мы может воспользоваться тем фактом, что оператор *yield* это последнее выражение в методе и по этому является возвращаемым значением, а так же фактом, что Ruby позволит нам передать любую строку блоку.

```ruby
it "does not display if not logged_in" do
  expect(logged_in?).to be_falsy
  expect(if_logged_in {"logged in"}).to be_nil
end

it "displays if logged_in" do
  login_as users(:quentin)
  expect(logged_in?).to be_truthy
  expect(if_logged_in {"logged in"}).to eq("logged in")
end
```

Тут нужно быть аккуратным, т.к. эти тесты проверяют только возвращаемые методами значения, а не то, что отправляется на выход. Выходной поток - это часть стороннего эффекта процесса, но он хранится в переменной *output_buffer*, к которой можно получить доступ во время тестирования. Таким образом, данные тесты можно переписать:

```ruby
it "does not display if not logged_in" do
  expect(logged_in?).to be_falsy
  if_logged_in {"logged in"}
  expect(output_buffer).to be_nil
end

it "displays if logged_in" do
  login_as users(:quentin)
  expect(logged_in?).to be_truthy
  if_logged_in {"logged in"}
  expect(output_buffer).to be_nil
end
```

<div id='user-content-chapter-8.6'/></div>
### Тестирование представлений

Мы тестировали хелпер на статус проекта, но когда мы заходим в браузер DOM-элементы нового статуса не отображаются. Это потому, что мы не использовали хелпер на шаблоне представления. 

С точки зрения TDD у нас есть несколько вариантов:
 - Не писать тесты и просто вставить хелпер в шаблон представления. Технически мы не добавляем логику, по этому не добавление тестов может быть оправданным в случае, если тест: а) дорогой, б) незначительный и в) легко определяемый визуально.
 - Написать интеграционные тесты используя Capybara.
 - Написать тести представлений. У них преимущество в скорости перед интеграционными тестами и можем комбинировать их с уже написанными тестами контроллера.

План теста представления
 - Дано: Нам нужно всего два проекта: один, который вкладывается в график, второй - нет. Это позволит проверить оба варианта хелпера. Проект, который мы создаем, должен быть видим для метода контроллера, то есть мы должны либо добавить данные в БД, либо сделать подделку. (Так же можно использовать испытательные стенды (fixtures), но я не хочу их создавать, т.к. не хочу, чтоб данные проекты были глобальные.) Давайте начнем с БД, на данный момент это самое простое решение.
 - Условия: Нам просто нужно вызвать действие *index* контроллера.
 - Далее: У проекта, который вкладывается в график, DOM класс *on_schedule* и у опаздывающего проекта класс *behind_schedule*.

```ruby
# spec/views/projects/index.html.erb_spec.rb
require 'rails_helper'

describe "projects/index" do
  let(:completed_task) {Task.create!(completed_at: 1.day.ago, size: 1)}
  let(:on_schedule) {Project.create!(due_dateL 1.year.from_now,
    name: "On Schedule", tasks: [completed_task])}
  let(:incomplete_task) {Task.create!(size: 1)}
  let(:behind_schedule) {Project.create!(due_dateL 1.day.from_now,
    name: "Behind Schedule", tasks: [incomplete_task])}

  it "renders the index page with correct DOM elements" do
    @projects = [on_schedule, behind_schedule]
    render
    expect(rendered).to have_selector(
      "#project_#{on_schedule.id} .on_schedule")
    expect(rendered).to have_selector(
      "#project_#{behind_schedule.id} .behind_schedule")
  end
end
```

Сличитель *have_selector* не является частью RSpec, он относится к Capybara. 

Что делает этот тест?

Сначала мы создаем данные. Мы используем *let* для создания успевающего проекта и задания. Есть возможность сделать тест быстрее создавая проект и делая метод-заглушку *on_schedule?* или используя FactoryGirl.build_stubbed для создания реальных объектов без необходимости сохранять их в БД.

Секция "Условия" начинается на строке *render*, которая говорит RSpec рендерить представление, описанное во внешнем блоке *describe*. В нашем случае *projects/index*. Так же можно явно указать аргумент: *render template: "projects/index"*. Если представление парциальный шаблон, нужно указать это: *render partial: "projects/data_row"*. Необязательный аргумент *locals* вида ключ/значение указывает локальные переменные для парциала. Сокращенно можно так: *render "projects/data_row", project: @project*.

Все Rails хелперы загружены. Если захочется подделать одно из их значений, доступ к хелперам можно получить через *view* объект, например, *view.stub(:current_user).and_return(User.new)*. Так же можно использовать *stub_template* для подделки парциала, который не хочется рендерить; *stub_template* принимает пару ключ/значение, где ключ это точное имя парциала, а значение - строка, которая будет возвращена на месте отрендеренного парциала. 

В секции "Потом" рендерящийся текст доступен через метод *rendered*. Относительно ожиданий по его значению можно использовать любой RSpec сличитель. В этом тесте мы используем *have_selector*, но можем использовать *match* для простого сравнения с регулярным выражением.

Сличитель *have_selector* разработан Capybara для испольования в RSpec и обычно используются для проверки существования селектора на выходе отрендеренного действием контроллера. 

Тест провалится с примерно такой ошибкой:

```ruby
Failure/Error: expect(response).to
      have_selector("#project_#{on_schedule.id} .on_schedule")
      expected to find css "#project_980190963 .on_schedule"
      but there were no matches
```

Небольшие изменения в шаблоне *index* и наш тест пройдет - нужно лишь изменить имя ячейки проекта используя хелпер *name_with_status*.

```erb
<!-- app/views/projects/index.html.erb -->
<h1>All Projects</h1>
<table>
  <thead>
    <tr>
      <td>Project Name</td>
      <td>Total Project Size</td>
    </tr>
  </thead>
  <tbody>
    <% @projects.each do |project| %>
      <tr class="project-row" id="<%= dom_id(project) %>">
        <td class="name"><%= name_with_status(project) %></td>
        <td class="total-size"><%= project.total_size %></td>
      </tr>
    <% end %>
  </tbody>
</table>
```

Использовать *have_selector* можно несколькими способами. Аргументом может быть только элемент, такой как *div*, или же элемент плюс класс или ID, например *div.hidden*. Так же можно использовать квадратные скобки для определения атрибутов HTML: *input[name='email']*. Более детально в документации Capybara. 

> Принцип 21. **При тестировании элементов представления желательно проверять DOM классы, нежели текст или имена элементов, которые могут меняться при смене дизайна.**

Так же можно добавлять в сличитель *have_selector* необязательный аргумент *text*, значением которого должна быть строка или регулярное выражение. 

```ruby
have_selector("#project_#{on_schedule.id} .on_schedule", text: "On Schedule")
```

Так же можно добавлять аргумент *count*, который принимает значение integer. В таком случает *have_selector* пройдет проверку только, если количество совпадений будет равно значению аргумента *count*. Так же можно указать диапазон с помощью *between* или же обозначить *maximum* или *minimum*.

```ruby
have_selector("#project_#{on_schedule.id} .on_schedule", count: 1)
```

Бывает полезно проверить, что элемент не отображается на странице, как например кнопка администратора. Capybara предоставляет для этого *have_no_selector*, который лучше уживается с асинхронным яваскриптом, нежели *not_to have_selector*.

<div id='user-content-chapter-8.7'/></div>
### Презентеры (Presenters)

Если в ваших хелперах много логики, я рекомендую переместить логику в объекты презентеров. Это особенно оправдано, если ряд хелперов принимают одинаковый аргумент.

Нет ничего сложного в тестировани презентеров в Rails. Зачастую я использую класс SimpleDelegator, а для большей структурированности можно подключить gem *drapper*.

```ruby
# app/presenters/project_presenter.rb
class ProjectPresenter < SimpleDelegator

  def self.from_project_list(*projects) 
    projects.flatten.map { |project| ProjectPresenter.new(project) }
  end

  def initialize(project) 
    super
  end

  def name_with_status 
    dom_class = on_schedule? ? 'on_schedule' : 'behind_schedule'
    "<span class='#{dom_class}'>#{name}</span>"
  end

end
```

Главное действие тут initialize. Все, что нам нужно сделать, так это вызвать *super* и *SimpleDelegator* обо всем позаботится: если он получит непонятно сообщения, то автоматически делегирует его объекту переданному конструктору. На практике это означает, что мы рассматриваем презентер как экземпляр подлинного объекта. Плюс презентер включает все методы, которые мы к нему добавили. 

Т.к. методы *on_schedule?* или *name* сейчас делегированы, нет нужны в явном вызове объекта project как получателя: мы можем просто использовать *on_schedule?* вместо *project.on_schedule?*. Тем не менее, с тех пока как мы не внутри хелпера, у нас нет доступа к методу *content_tag* и мы вынуждены писать HTML вручную. 

В итоге вверху класса у нас метод, который принимает список экземпляров Project и конвертирует их в презентеры. Аргумент **projects* вместе с *projects.flatten* позволяет методу быть вызванным как для массива *ProjectPresenter.from_project_list([p1, p2])*, так и для обычного списка проектов *ProjectPresenter.from_project_list(p1, p2)*.

Тест презентера довольно легкий:

```ruby
# spec/presenters/project_presenter_spec.rb
require 'rails_helper'

describe ProjectPresenter do
  let(:project) { instance_double(Project, name: "Project Runway") }
  let(:presenter) { ProjectPresenter.new(project) }

  it "handles name with on time status" do
    allow(project).to receive(:on_schedule?).and_return(true)
    expect(presenter.name_with_status).to eq(
        "<span class='on_schedule'>Project Runway</span>")
  end

  it "handles name with behind schedule status" do
    allow(project).to receive(:on_schedule?).and_return(false)
    expect(presenter.name_with_status).to eq(
        "<span class='behind_schedule'>Project Runway</span>")
  end
end
```

Т.к. у класса презентера нет зависимостей от Rails, мы можем написать тест, в котором так же не будет зависимостей от Rails. Мы заменили настоящий объект *project* подделкой. 

Т.к. у теста нет зависимостей от Rails, мы не нуждаемся в его окружении - и приложив немного усилий можем заменить *require 'rails_helper'* вверху файлы на *require 'spec_helper'*. То есть мы можем запускать тест без запуска Rails, что приведет к повышению скорости выполнения теста.

<div id='user-content-chapter-8.8'/></div>
### Тестирование рассыльщиков (Mailers)

Тестирование рассыльщиков в Rails включает две части: проверка отправки письма после определенного действия и проверка содержимого письма. Отправка письма обычно проверяется тесте контроллера или интеграционном тесте, в то время как у проверка содержимого письма много общего с тестированием представлений. Несколько косвенный характер ActionMailer в Rails делает тестирование писем менее очевидным, чем должно быть, но это не сложно. Мы так же рассмотрим стороннюю библотеку для облегчения задачи.

К примеру, мы хотим, чтоб отправлялось письмо, когда задание обозначается выполненным. Давайте сфокусируемся на действии контроллера, которое обрабатывает отмечание задания выполненным. 

Подумаем, о том, что нам нужно:
 - Дано: Нам нужно задание, которое изначально невыполнено;
 - Условия: Действие теста это действие контроллера. В RESTful Rails интерфейсе это действие будет *TasksController#update*. Действие контроллера применяет параметр *completed: true*.
 - Далее: Задание обновляется и письмо отправляется.

> Принцип 22. При тестировании логического(boolean) условия пишите тесты для обоих случаев.

```ruby
# spec/controllers/tasks_controller_spec.rb
require 'rails_helper'

RSpec.describe TasksController, :type => :controller do
  before(:example) do
    ActionMailer::Base.deliveries.clear 
  end

  describe "PATCH update" do
    let(:task) { Task.create!(title: "Write section on testing mailers", size: 2) }
    it "does not send an email if a task is not completed" do
      patch :update, id: task.id, task: {size: 3}
      expect(ActionMailer::Base.deliveries.size).to eq(0) 
    end
  end
end
```

Мы используем блок *before(:example)* и очищаем объект *ActionMailer::Base.deliveries* для того, чтобы быть уверенным, что структура содержащая рассылку очищена. Так же нужно удостовериться, что файл *config/environments/test.rb* содержит строку *config.action_mailer.delivery_method = :test*. 

Тест пройдет со следующим методом контроллера (плюс чистый шаблон в *app/views/tasks/edit.html.erb*):

```ruby
# app/controllers/tasks_controller.rb
class TasksController < ApplicationController
  def update
    @task = Task.find(params[:id])
    if @task.update_attributes(params[:task].permit(:size))
      redirect_to @task, notice: "'project was successfully updated.'"
    else
      render action: 'edit'
    end
  end

  def show
    @task = Task.find(params[:id])
  end
end
```

А вот тест с выполненным заданием, который проверяет поведение рассылки.

```ruby
# spec/controllers/tasks_controller_spec.rb
    # ...
    it "sends email when task is completed" do
      patch :update, id: task.id, task: {size: 3, completed: true}
      task.reload  
      expect(task.completed_at).to be_present
      expect(ActionMailer::Base.deliveries.size).to eq(1)
      email = ActionMailer::Base.deliveries.first 
      expect(email.subject).to eq("A task has been completed")
      expect(email.to).to eq(["monitor@tasks.com"])
      expect(email.body.to_s).to match(/Write section on testing mailers/)
    end
    # ...
```

Мы имитировал вызов метода *update* на этот раз с аттрибутом *completed*. Далее мы перегрузили объект задания для применения изменений и удостоверились, что атрибут *completed_at* обновился. 

Далее мы перешли к рассыльщику. Удостоверились, что письмо было отослано и проверили его на соответствие темы, получателя и содержания.

Тест провалится. Прежде всего из-за проверки атрибута *completed_at*. По этому внесем изменения в контроллер:

```ruby
# app/controllers/tasks_controller.rb
class TasksController < ApplicationController

  def update
    @task = Task.find(params[:id])
    completed = params[:task].delete(:completed)
    params[:task][:completed_at] = Time.current if completed
    if @task.update_attributes(params[:task].permit(:size, :completed_at))
      TaskMailer.task_completed_email(@task).deliver if completed
      redirect_to @task, notice: "'project was successfully updated.'"
    else
      render action: 'edit'
    end
  end

  def show
    @task = Task.find(params[:id])
  end
end
```

Теперь нам нужен сам рассыльщик. Мы можем сгенерировать его из коммандной строки используй Rails генератор:

```
$ rails generate mailer TaskMailer
create app/mailers/task_mailer.rb
      invoke  erb
      create    app/views/task_mailer
      invoke  rspec
      create    spec/mailers/task_mailer_spec.rb
```

Далее нам нужно изменить рассыльщик: указать задание и определить некоторые значения.

```ruby
# app/mailers/task_mailer.rb
class TaskMailer < ActionMailer::Base
  default from: "from@example.com"

  def task_completed_email(task)
    @task = task
    mail(to: "monitor@tasks.com", subject: "A task has been completed")
  end
end
```

И шаблон:

```erb
<!-- app/views/task_mailer/task_completed_email.text.erb -->
The task <%= @task.title %> was completed at <%= @task.completed_at.to_s %>

Thanks,

The Management
```

И тесты пройдут проверку. 

Внешняя библиотека *email-spec* предоставляет ряд очень полезных хелперов. В основном она выполняет эти же тесты, но слегка улучшенным синтаксисом. Она так же предоставляет возможность последовать ссылке в письме обратно на сайт, что очень полезно для приемочных тестов.

<div id='user-content-chapter-8.9'/></div>
### Управление тестами контроллеров и представлений

Тестирование контроллеров и представлений довольно каверзная часть тестирования Rails-приложения. В отличии от тестирования модели (которое стремится быть изолированным) или интеграционного тестирование (которое покрывает весь стек), границы тестирования контроллеров и представлений весьма размыты. В идеале, тесты контроллера должны быть написаны с минимальным взаимодействием с моделью. Сфокусированные тесты представлений возможны, но они сильно перекрываются тестами хелперов, логиков в объектах презентеров и интеграционном тестировании.



<div id='user-content-chapter-10'/></div>
## 10. Интеграционное тестирование с Capybara и Cucumber

Интеграционное тестирование определяет совместное поведение нескольких частей приложения.

Существует три родственных понятия. **Интеграционный** тест - это общее название для теста, который совмещает более одного блока. В Rails, интеграционные тесты часто являются **комплексными**, то есть они охватывают всю систему извне, делая запросы как пользователь и проверяя результат, который был бы виден пользователю. **Приемочный** тест комбинирует комплексный тест с идеей, что тест определяет не только поведение, ожидаемое для программы, но и поведение, правильное на взгляд пользователя или заказчика. Таким образом, любомй приемочный тест интеграционный, но не любой иитеграционный тест приемочный.

В этой главе мы сфокусируемся на интеграционных тестах, который так же и комплексные, предполагая что нам нужны инструменты для имитирования HTTP-запросов и оценки HTTP-ответов.

<div id='user-content-chapter-10.1'/></div>
### Что тестировать в интеграционном тесте

Ранее мы говорили об идее пирамыды тестирования, где среди ваших тестов сравнительно большое количество блочных тестов, которые быстро запускаются и тестируют один небольшой сегмент приложения, и значительно меньшее количество интеграционных тестов, которые в целом проходят более медленно. 

Более наглядно можно представить интеграционные тесты как каркас здания. Без интеграционных тестов нельзя определить, как приложение работает целиком. Без блочных тестов баги полезут из всех щелей. 

> Принцип 23. Имея дело с интеграционными тестами не поддавайтеся искушению использовать их в качестве блочных.

Интеграционный тест уместен, если уникальная точка провала касается взаимодействия двух объектов (или двух методов объекта). Если же уникальная точка провала тест относится к внутренней логике одного и того же объекта, то лучше покрыть ее блочным тестом.

Когда использовать интеграционные тесты:
 - при взаимодействии между контроллером и моделью или другими объектами, которые предоставляют данные;
 - при взаимодействии нескольких действий контроллера, который охватывают общий рабочий поток;
 - при некторых сервисных проблемах включающих взаимодействие пользователя и определенного действия контроллера.

Когда не использовать интеграционный тесты (а использовать блочные):
 - при специальных случаях бизнес-логики, таких как: что случится, если данные отсутствуют или имеют неправильные значения;
 - случаи ошибок, если только это не уникальные случаи;
 - реализация внутренних деталей бизнес-логики.

Две проблемы случаются, когда мы покрываем интеграционными тестами вещи, для которых лучше использовать блочные тесты. Во-первых, скорость. Интеграционные тесты медленнее. Во-вторых, точность. Потому что интеграционные тесты не делают предположений до того как внутренняя логика выполнится и по этому бывает сложно понять в чем проблема.

<div id='user-content-chapter-10.2'/></div>
### Настройка Capybara

Capybara позволяет автоматизированным тестам имитировать пользовательское взаимодействие с браузером. При этом Capybara работает вместе с драйвером, используя Capybara API для определения с какими элементами взаимодействовать. По умолчанию Capybara использует родную библиотеку Ruby, которая не управляет JavaScript взаимодействиями, но может быть для этого настроена, чтоб использовать PhantomJS или Selenium.

#### Capybara и RSpec

Capybara разработана для использования с RSpec и для использования их вместе добавьте Capybara в гемфайл в группу тестирования:

```
gem 'сapybara', group: :testing
```

Так же потребуется добавить следующую строку в *rails_helper.rb* вверху:

```ruby
require 'capybara/rails'
```

#### Capybara и Minitest

Настройка Minitest такая же, только гем другой:

```
gem 'minitest-rails-сapybara', group: :testing
```

Так же потребуется добавить следующую строку в *test_helper.rb* вверху:

```ruby
require 'minitest/rails/capybara'
```

<div id='user-content-chapter-10.3'/></div>
### Тестирование "от общего к частному" (Outside-in)

Процесс, который мы будем использовать для управления тестами Capybara иногда называют тестированием от общего к частому - мы начнем использовать Capybara для написания теста от общего и используем этот тест для управления нашими блочными тестами. Так же, как и TDD используем провальные блочные тесты для управления кодом, тестирование от общего к частному использует провальный приемочный тест (или провальную строку приемочного теста) для управления созданием блочных тестов.

Мы собираемся создать новую функцию в Rails-приложении.

Давайте пройдемся по пунктам.

1. Написать комплексный тест, который показывает пользовательское взаимодействие с новой функцией. Тест должен указывать данные, иметь одну или более пользовательский взаимодействий и проверять HTML-ответы, чтоб определить, что взаимодействия проходят, как ожидалось. Тест должен быть общим, безошибочным, взаимодействием функции. Прежде процесс начнется, было бы хорошо пройтись по контроллерам и представлениям пытаясь понять, как должно выглядеть взаимодействие пользователя. Можете даже написать основную часть функции. Но вы должны быть готовы переписать этот код как только тестирование начнется.

2. Начать запуск тестов. В довольно зрелом приложении первые несколько шагов уже пройдены. Вы часто будете добавлять новые функции к существующей странице, по этому шаги, в которых подготовливаются данные, пользователи логинятся и загружаются существующие страницы, должны работать.

3. Дойдет до провала теста. Первые провалы в интеграционном тесте зачастую незначительны: попытки кликнуть по несуществующей ссылке или заполнить несозданную форму. Они могут быть быстро исправлены без блочных тестов, так как в теории добавлении элементов в представление не является тестируемой логикой.

4. И вот в итоге вы упираетесь в пропасть. Вы достигаете точки, где вы проверяете запросы и при этом множество логики в коде пропущено. Теперь у вас появляется четко определенное задание и время перейти к блочным тестам.

5. Какой именно блочный тест писать, зависит от ситуации. Суть в том, что блочные тесты идут помимо самих интеграционных тестов. 

6. Когда блочные тесты будут готовы, возвращайтесь к интеграционному тест. Возможно он опять упадет, если вы забыли написать часть интеграционной логики. Не проблема: именно для этого и нужны интеграционные тесты.

7. Наконец-то интеграционный тест проходит. Если есть другой значительный случай взаимодействия пользователя с функцией, пишите тест и начинайте заново.

Давайте попробуем пример на практике.

<div id='user-content-chapter-10.4'/></div>
### Использование Capybara

Последний раз оставляя наше приложении мы могли создавать новые проекты. Давайте продолжим и добавим возможность видеть страницу существующего проекта и добавлять к нему задание. И чтоб прибавить немного бэкэнд логики, с которой можно поиграть, давайте установим ситуацию, при которой задания упорядочены и мы хотим подвинуть одно задание выше другого.

#### Написание теста

У этого теста есть несколько разных частей. Давайте на секунду прервемся и составим план:
 - Дано: Нам нужен один существующий проект и хотя бы одно существующее задание в этом проекте для тестирования упорядочивания. Мы вероятно захотим два задания; таким образом мы сможем проверить корректность пользовательского интерфейсадля первой, последней и средней частей списка.
 - Условие/Далее: Пользователь заполняет форму для нового задания и мы проверяем отображение нового задания.
 - Условие/Далее: Пользователь перемещает задание вверх и мы проверяем изменение порядка.

Факт присутствия двух пунктов "Условие/Далее" говорит о том, что желательно сделать два теста, но для простоты объяснений мы сделаем один. Давайте на него взглянем:

```ruby
# spec/features/add_task_spec.rb
require 'rails_helper'

describe "adding a new task" do
  fixtures :all

  it "can add and reorder a task" do
    visit project_path(projects(:bluebook))
    fill_in "Task", with: "Find UFOs"
    select "2", from: "Size"
    click_on "Add Task"
    expect(current_path).to eq(project_path(projects(:bluebook)))
    within("#task_3") do
      expect(page).to have_selector(".name", text: "Find UFOs")
      expect(page).to have_selector(".size", text: "2")
      expect(page).not_to have_selector("a", text: "Down")
      click_on("Up")
    end
    expect(current_path).to eq(project_path(projects(:bluebook)))
    within("#task_2") do
      expect(page).to have_selector(".name", text: "Find UFOs")
    end
  end
end
```

Тест немного длинноват и несвязный. Он так же не полностью тестирует интерфейс пользователя в том смысле, что не проверяет существование всех ссылок "Вверх" и "Вниз". Тест проходит по взаимодействию удобно затрагивая важную часть Capybara API.

Давайте пройдемся по Capybara API, просматривая каждый вызов метода, который мы использовали, а так же изучая сопутствующие методы. Далее мы пройдемся по остальной части процесса и заставим тест пройти.

#### Capybara API: навигация

У Capybara есть метод для навигации по маршрутам приложения и это первая строка в нашем тесте: *visit project_path(projects(:runaway))*. Метод *visit* принимает один аргумент - строку URL (в нашем случае метод маршрутизации, который возвращает строку URL). Маршрут генерируемый методом *visit* это всегда *HTTP GET*. Если хотите имитировать *POST* или любой другой НТТР-метод, рекомендуемым механизмом в Capybara является навигация по ссылки или кнопке формы на странице, которая выполняет жилаемое действие.

#### Capybara API: взаимодействие

После того, как наш тест переходит по URL *project_path*, мы начинаем использовать методы Capybara для взаимодействия с элементами страницы. А именно, мы используем метод *fill_in* для размещений текста в текстовом поле, далее метод *select* для выбора варианта в меню выбора и наконец-то метод *click_on*, чтоб кликнуть на кнопке и отправить форму. У Capybara есть около десяти методов для взаимодействия с элементами DOM.

Capybara очень гибкий в плане выбора элементов. Можно указать любой элемент по его DOM ID. Элементы формы так же могут быть указаны по атрибуту *name*. Элементы формы прикрепленные к тегу *label* могут быть определены по тексту прикрепленного *label*. Элементы, такие как якорные теги HTMl, которые имеют внутренний текст, могут быть указаны по этому тексту. Анкерные теги HTML, телом которого является изображение, могут быть обнаружены по текстовому атрибуту *alt* для изображения. 

Другими словами, если у вас есть следующий HTML-отрывок:

```html
<form>
  <label for="user_email">Email</label>
  <input name="user[email]" id="user_email">
</form>
```

можно использовать Capybara для доступа к форме любым из следующих способов:

```ruby
fill_in("user_email", with: "noel@noelrappin.com")
fill_in("user[email]", with: "noel@noelrappin.com")
fill_in("Email", with: "noel@noelrappin.com")
```

Первый использует DOM ID, второй - имя формы, а третий - текст в *label*. 

По умолчанию Capybara сранивает подмножества, по этому можно так же использовать "em" как сличитель, если хотите. Если подходят более одного элемента, то Capybara выдает ошибку. (Такое поведение характерно для Capybara версии 2.2, старые версии ведут себя по-другому.) Если нужно строгое совпадение, не включая подстроку, передайте параметр *exact:true* любому методу Capybara, который использует локатор.

Какой поиск текста использовать? Зависит от ситуации. Поиск по тексту в *label* наиболее читаемый. Но он так же и самый хрупкий, т.к. этот текст легко может быть изменен. В то же время поиск по DOM ID наименее читаемый, но при этом ID врятле подвергнется изменению.

Список методов Capybara для взаимодействия с формой:

<dl>
  <dt>check(locator)</dt>
  <dd>Поиск чекбокса по <i>locator</i> и его отмечание.</dd>
  <dt>choose(locator)</dt>
  <dd>То же, что и <i>check</i>, только для радиокнопок.</dd>
  <dt>fill_in(locator, with: "text")</dt>
  <dd>Локатор должен найти текствое поле и разместить туда значение из параметра <i>with</i>.</dd>
  <dt>select(value, from: locator)</dt>
  <dd>Поиск меню выбора, которое совпадает с локатором из параметра <i>from</i> и установка его значения значением первого аргумента. </dd>
  <dt>click_on(locator)</dt>
  <dd>Находит якорную ссылку или кнопку по локатору и имитирует на нем клик.</dd>
</dl>

Далее еще несколько методов, которые вы наверное будете использовать реже.

<dl>
  <dt>attach_file(locator, path)</dt>
  <dd>Имитирует прикрепление файла по данному пути к форме, найденной по локатору</dd>
  <dt>click_button(locator); click_link(locator)</dt>
  <dd>Как <i>click_on</i>, только для кнопки или ссылки.</dd>
  <dt>uncheck(locator)</dt>
  <dd>Снимает статус "отмечено" с чекбокса, найденного по локатору</dd>
  <dt>unselect(value, from: locator)</dt>
  <dd>Этот метод снимает статус "выбрано" с сэлектбокса, найденного по локатору. Полезен для сэлектбоксов с возможностью выбора нескольких значений.</dd>
</dl>

#### Capybara API: запросы

У Capybara есть несколько методов для запроса имитированной страницы браузера, чтоб проверить наличие на ней разных селекторов. В этом случае синтаксис между Minitest и RSpec будет слегка отличаться. 

Наиболее распространенный метод запроса в Capybara - это сличитель *have_selector* в RSpec и *assert_selector* в Minitest. Они идентичны. По умолчанию Capybara ищет CSS-селектор, совпадающий с аргументом метода запроса, используя # для DOM ID и точку (.) для DOM класса аналогично тому, как мы видели в тестах представлений. 

Если нужно указать, что данные селектор не находится на странице, в RSpec можно использовать эквивалентные методы *not_to have_selector* или *have_no_selector*. В Minitest нужно использовать *assert_no_selector*. 

Сначала наш тест использует *have_selector* чтоб удостовериться, что элементы *.name* и *.size* присутствуют и совпадают с соответствующими дополнительным аргументами. Все методы Capybara принимают дополнительные аргументы, включая *text* и *count*. *text* принимает строку или регулярное выражение, которое должно совпадать с содержимым выбранного элемента. *count* должен совпадать с количеством элементов на странице.

Так же есть метод *has_link?*, который принимает локатор. 

Наш тест так же использует метод *within*, который принимает селектор в качестве аргумента и блок. По селектору, переданному *within*, будет найдет один элемент. Методы в блоке применимы к содержимому найденного элемента. 

```ruby
within("#task_2") do
  expect(page).to have_selector(".name", text: "Cast the designers")
end
```

Данная часть теста пройдет только если элемент *.name* будет внутри *#task_2*. 

Наиболее полезным методом Capybara, когда что-то не получается, является *save_and_open_page*, который сбрасывает содержимое Capybara DOM во временный файл и открывает этот файл в браузере (для открытия в браузере нужен гем *launchy*). Там не будет картинок или CSS, но и этого обычно достаточно для того, чтоб, к примеру, дать понять, что вы застряли на окне входа, потому что забыли создать авторизованного пользователя.

<div id='user-content-chapter-10.5'/></div>
### Заставляя пройти тест Capybara

Пройдемся по процессу интеграционного теста.



<div id='user-content-chapter-10.6'/></div>
### Ретроспектива

<div id='user-content-chapter-10.7'/></div>
### Пробуем Cucumber

<div id='user-content-chapter-10.8'/></div>
### Настройка Cucumber

<div id='user-content-chapter-10.9'/></div>
### Написание функций Cucumber

<div id='user-content-chapter-10.10'/></div>
### Шаги написания тестов с Cucumber

<div id='user-content-chapter-10.11'/></div>
### Продвинутый Cucumber

<div id='user-content-chapter-10.12'/></div>
### Стоит ли Cucumber того?

<div id='user-content-chapter-10.13'/></div>
### Заглядывая вперед